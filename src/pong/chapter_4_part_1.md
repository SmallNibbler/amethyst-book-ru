# Настройка проекта

В этой главе мы рассмотрим основы настройки проекта Amethyst, запуска логгера, открытия окна и подготовки простой настройки рендеринга.

## Создание нового проекта

Давайте начнем новый проект:

>\> `amethyst new pong`

Обновите зависимости в файле `Cargo.toml` проекта, чтобы он содержал:

```toml
[package]
name = "pong"
version = "0.1.0"
authors = []
edition = "2018"

[dependencies.amethyst]
version = "0.14"
features = ["vulkan"]
```

В качестве альтернативы, если вы разрабатываете на macOS, вы можете использовать бэкэнд рендеринга metal вместо vulkan. В этом случае вам следует изменить запись features в таблице зависимостей amethyst.

```toml
[dependencies.amethyst]
version = "0.14"
features = ["metal"]
```

Мы можем начать с редактирования файла `main.rs` внутри каталога `src`. Вы можете удалить все в этом файле, а затем импортировать эти модули:

```rust,ignore
//! Pong Tutorial 1

use amethyst::{
    prelude::*,
    renderer::{
        plugins::{RenderFlat2D, RenderToWindow},
        types::DefaultBackend,
        RenderingBundle,
    },
    utils::application_root_dir,
};
```

Мы узнаем больше об этом, когда пройдем этот урок. `prelude` включает в себя основные (и наиболее важные) типы, такие как приложение (`Application`), мир (`World`) и состояние (`State`). Мы также импортируем все необходимые типы, чтобы определить базовый конвейер рендеринга.

Теперь у нас установлены все зависимости и подготовлен импорт, и мы готовы приступить к определению кода нашей игры.

## Создание игрового состояния

Теперь мы создаем нашу основную структуру игры:

```rust,edition2018,no_run,noplaypen
pub struct Pong;
```

Мы будем реализовывать типаж `SimpleState` в этой структуре, которая используется конечным автоматом Amethyst для запуска, остановки и обновления игры.

```rust,ignore
impl SimpleState for Pong {}
```

Реализация `SimpleState` учит наше приложение, что делать, когда от вашей операционной системы поступает сигнал закрытия. Это происходит при нажатии кнопки закрытия в графическом окружении. Это позволяет приложению выходить по мере необходимости.

Теперь, когда наша структура `Pong` это состояние игры, давайте добавим немного кода! Мы начнем с нашей функции `main()`, она возвращает `Result`, чтобы мы могли использовать `?`. Это позволит нам автоматически выйти, если во время установки возникнут какие-либо ошибки.

```rust,edition2018,no_run,noplaypen
# extern crate amethyst;
# use amethyst::prelude::*;
fn main() -> amethyst::Result<()> {

    // Мы разместим остальную часть кода здесь.

    Ok(())
}
```

> **Примечание.** `SimpleState` - это просто упрощенная версия типажа `State`. Он уже реализует для нас кучу вещей, таких как методы `update` и `handle_event`, которые вы должны были бы реализовать самостоятельно, если бы использовали обычный типаж `State`. Его поведение в основном касается аккуратной обработки сигнала на выход из приложения непосредственно из текущего состояния.

## Настройка логгера

Внутри `main()` мы сначала запускаем логгер со стандартным `LoggerConfig`, чтобы мы могли видеть ошибки, предупреждения и сообщения отладки во время работы программы.

```rust,edition2018,no_run,noplaypen
# extern crate amethyst;
#
# fn main() {
amethyst::start_logger(Default::default());
# }
```

Отныне каждая информация, предупреждение и ошибка будут присутствовать и четко форматироваться внутри окна вашего терминала.

> **Примечание.** Существует много способов настройки этого логгера, например, для записи журнала в файловую систему. Вы можете найти больше информации о том, как это сделать, в Справочнике по [Logger API][logger-api]. Мы будем использовать самые основные настройки в этом руководстве для простоты.

[logger-api]: https://docs.amethyst.rs/stable/amethyst/struct.Logger.html

## Подготовка конфигурации дисплея
Далее нам нужно создать `DisplayConfig` для хранения конфигурации окна нашей игры. Мы можем определить конфигурацию в нашем коде или, что еще лучше, загрузить ее из файла. Последний подход удобнее, поскольку он позволяет нам изменять конфигурацию (например, размер окна) без необходимости каждый раз перекомпилировать нашу игру.

При создании проекта с помощью `amethyst new` должны автоматически генерироваться данные `DisplayConfig` в `config/display.ron`. Если вы создали проект вручную, создайте его сейчас.

В любом случае откройте `display.ron` и измените его содержимое на следующее:

```rust,ignore
(
    title: "Pong!",
    dimensions: Some((500, 500)),
)
```

> **Примечание.** Если вы никогда ранее не сталкивались с Rusty Object Notation (или RON для краткости), это формат хранения данных, который отражает синтаксис Rust. Здесь данные представляют структуру [`DisplayConfig`][display-config]. Если вы хотите узнать больше о синтаксисе RON, вы можете посетить [официальный репозиторий][official-repository].

[display-config]: https://docs.amethyst.rs/stable/amethyst_renderer/struct.DisplayConfig.html
[official-repository]: https://github.com/ron-rs/ron

Это установит размеры окна по умолчанию на 500 x 500, и заголовок "Pong!" вместо грустного, строчного «pong» по умолчанию.

В функции `main()` файла `main.rs` мы подготовим путь к файлу, содержащему конфигурацию дисплея:

```rust,edition2018,no_run,noplaypen
# extern crate amethyst;
#
# use amethyst::{
#     utils::application_root_dir,
#     Error,
# };
#
# fn main() -> Result<(), Error>{
let app_root = application_root_dir()?;
let display_config_path = app_root.join("config").join("display.ron");
#     Ok(())
# }
```

## Создание приложения

В функции `main()` файла `main.rs` мы собираемся добавить базовую настройку приложения:

```rust,edition2018,no_run,noplaypen
# extern crate amethyst;
# use amethyst::{
#     prelude::*,
#     utils::application_root_dir,
# };
# fn main() -> Result<(), amethyst::Error> {
# struct Pong; impl SimpleState for Pong {}
let game_data = GameDataBuilder::default();

# let app_root = application_root_dir()?;
let assets_dir = app_root.join("assets");
let mut game = Application::new(assets_dir, Pong, game_data)?;
game.run();
#     Ok(())
# }
```

Здесь мы создаем новый экземпляр `GameDataBuilder`, центральное хранилище всей игровой логики, которое периодически запускается во время игры. Сейчас он пуст, но скоро мы начнем добавлять в него всевозможные системы и комплекты, которые будут запускать наш игровой код.

Затем этот конструктор объединяется со структурой состояния игры (`Pong`), создавая всеобъемлющий корневой объект Amethyst - [`Application`][application]. Он связывает цикл событий ОС, конечные автоматы, таймеры и другие основные компоненты в одном месте.

[application]: https://docs.amethyst.rs/stable/amethyst/type.Application.html

Затем мы вызываем метод `.run()` для объекта `game`, которая запускает игровой цикл. Игра будет продолжаться до тех пор, пока `SimpleState` не вернет `Trans::Quit` или пока все состояния не будут вытолкнуты из стека конечного автомата.

Теперь попробуйте скомпилировать код.

> **Примечание.** Обратите внимание, что при первой компиляции игры это может занять более получаса. Будьте уверены, что последующие сборки проекта будут быстрее.

Вы должны увидеть запуск приложения, но ничего не произойдет, и ваш терминал зависнет, пока вы не завершите процесс. Это означает, что основной игровой цикл работает по кругу и ожидает задания. Давайте дадим ему что-то сделать, добавив рендер!

## Настройка базового рендеринга

После подготовки конфигурации дисплея и настройки приложения пришло время его использовать. Мы оставили наш экземпляр `GameDataBuilder` пустым, теперь мы добавим к нему несколько систем.

```rust,edition2018,no_run,noplaypen
# extern crate amethyst;
# use amethyst::{
#     prelude::*,
#     renderer::{
#         plugins::{RenderFlat2D, RenderToWindow},
#         types::DefaultBackend,
#         RenderingBundle,
#     },
#     utils::application_root_dir,
# };
# fn main() -> Result<(), amethyst::Error>{
let app_root = application_root_dir()?;

let display_config_path = app_root.join("config").join("display.ron");

let game_data = GameDataBuilder::default()
    .with_bundle(
        RenderingBundle::<DefaultBackend>::new()
            // Плагин RenderToWindow предоставляет функционал для открытия окна и рисования на нем
            .with_plugin(
                RenderToWindow::from_config_path(display_config_path)?
                    .with_clear([0.0, 0.0, 0.0, 1.0]),
            )
            // Плагин RenderFlat2D используется для визуализации объектов с помощью компонента SpriteRender.
            .with_plugin(RenderFlat2D::default()),
    )?;
# Ok(()) }
```

Здесь мы добавляем комплект `RenderingBundle`. Комплекты - это, по сути, наборы систем, предварительно настроенных для совместной работы, поэтому вам не нужно записывать их все по одной.

> **Примечание.** Мы рассмотрим системы и комплекты более подробно позже. Пока что давайте думать о комплекте как о наборе систем, которые, в сочетании, обеспечат определенную функцию движку. Вы наверняка скоро напишете свои собственные комплекты для функций своей игры.

`RenderingBundle` отличается от большинства других комплектов: он сам по себе мало что делает. Вместо этого он использует собственную систему плагинов для определения того, что и как следует отображать. Мы используем метод `with_plugin`, чтобы сообщить ему, что мы хотим добавить плагины `RenderToWindow` и `RenderFlat2D`. Эти плагины дадут нашему рендереру возможность открывать окно и рисовать на нем спрайты.

В этой конфигурации наше окно будет иметь черный фон. Если вы хотите использовать другой цвет, вы можете настроить значения RGBA внутри `with_clear`. Значения варьируются от `0.0` до `1.0`, попробуйте использовать, например, `[0.00196, 0.23726, 0.21765, 1.0]`, чтобы получить красивое окно голубого цвета.

> **Примечание.** Этот установочный код использует систему, основанную на особенностях `RenderPlugin` Amethyst, которая использует пакет `rendy` для определения рендеринга. Если вы планируете выйти за рамки строительных блоков рендеринга, которые Amethyst предоставляет «из коробки», вы можете прочитать о графике рендеринга в [документации rendy][rendy-graph-docs].

[rendy-graph-docs]: https://github.com/amethyst/rendy/blob/master/docs/graph.md

Ура! Теперь мы можем скомпилировать и запустить этот код с помощью `cargo run` и получить окно. Это должно выглядеть примерно так:

![Окно с тёмным фоном.](..\images\chapter_4_part_1.png)

---

Документация была переведена специально для сообщества "**rust_lang_ru**".

Подпишись на нас в **[Telegram][telegram]** и **[YouTube][youtube]**!

[telegram]: http://tlinks.run/rust_lang_ru
[youtube]: https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA
