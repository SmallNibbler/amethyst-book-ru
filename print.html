<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Amethyst Документация</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li class="expanded "><a href="chapter_2.html"><strong aria-hidden="true">2.</strong> Начало работы</a></li><li class="expanded "><a href="chapter_3.html"><strong aria-hidden="true">3.</strong> Концепции</a></li><li><ol class="section"><li class="expanded "><a href="concepts/chapter_3_part_1.html"><strong aria-hidden="true">3.1.</strong> Состояния</a></li><li class="expanded "><a href="concepts/chapter_3_part_2.html"><strong aria-hidden="true">3.2.</strong> Сущность и компонент</a></li><li class="expanded "><a href="concepts/chapter_3_part_3.html"><strong aria-hidden="true">3.3.</strong> Ресурс</a></li><li class="expanded "><a href="concepts/chapter_3_part_4.html"><strong aria-hidden="true">3.4.</strong> Мир</a></li><li class="expanded "><a href="concepts/chapter_3_part_5.html"><strong aria-hidden="true">3.5.</strong> Система</a></li><li><ol class="section"><li class="expanded "><a href="concepts/system/chapter_3_part_5.1.html"><strong aria-hidden="true">3.5.1.</strong> Инициализация системы</a></li><li class="expanded "><a href="concepts/system/chapter_3_part_5.2.html"><strong aria-hidden="true">3.5.2.</strong> Производная SystemDesc</a></li><li class="expanded "><a href="concepts/system/chapter_3_part_5.3.html"><strong aria-hidden="true">3.5.3.</strong> Реализация типажа SystemDesc</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Amethyst Документация</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div style="display:inline-block;width:100%">
    <img src="./images/amethyst_emblem.png" alt="Logo" width="96px" style="float:left;margin-right:15px"/>
    <h1><a class="header" href="#Игровой-движок-amethyst" id="Игровой-движок-amethyst">Игровой движок Amethyst</a></h1>
</div>
<h1><a class="header" href="#Презентация" id="Презентация">Презентация</a></h1>
<p>Привет! Эта книга научит вас всему, что вам нужно знать о создании видео игр и интерактивных симуляций с помощью игрового движка <a href="https://amethyst.rs/">Amethyst</a>. Этот движок полностью написан на <a href="https://www.rust-lang.org/">Rust</a>, безопасном и быстром языке системного программирования, и отличается чистым и современным дизайном. Если быть более точным, Amethyst на самом деле представляет собой набор отдельных библиотек и инструментов, которые вместе составляют игровой движок.</p>
<p>Amethyst - это бесплатное программное обеспечение с открытым исходным кодом, распространяемое по двойной лицензии <a href="https://github.com/amethyst/amethyst/blob/master/docs/LICENSE-MIT">MIT</a> и <a href="https://github.com/amethyst/amethyst/blob/master/docs/LICENSE-APACHE">Apache</a>. Это означает, что движок предоставляется вам бесплатно, а его исходный код полностью ваш. Код доступен на <a href="https://github.com/amethyst/amethyst/tree/master">GitHub</a>. Вклады и пожелания всегда будут приветствоваться!</p>
<h1><a class="header" href="#Содержание" id="Содержание">Содержание</a></h1>
<p>Эта книга разделена на несколько разделов, причем это введение является первым. Другие разделы:</p>
<ul>
<li>Начало работы - подготовьте свой компьютер к разработке Amethyst.</li>
<li>Концепции - обзор концепций, используемых в Amethyst.</li>
<li>Pong Tutorial - создайте простую игру понг.</li>
<li>Математика - краткое введение в математику Amethyst.</li>
<li>Анимация - объясняет архитектуру пакета <code>amethyst_animation</code>.</li>
<li>Управление выполнением систем - показывает, как структурировать более сложные игры.</li>
<li>Глоссарий - определяет специальные термины, используемые в книге.</li>
<li>Приложение A. Файлы конфигурации - показывает, как определить ваши данные в файлах RON.</li>
</ul>
<p>Прочитайте <a href="https://docs.amethyst.rs/stable/amethyst/index.html">документацию API</a> пакета для получения дополнительной информации.</p>
<h1><a class="header" href="#Мотивация" id="Мотивация">Мотивация</a></h1>
<p>За прошедшие годы большинство из нашей команды работало с несколькими игровыми движками, а именно <a href="http://unity3d.com/">Unity</a>, <a href="https://www.unrealengine.com/">Unreal Engine</a>, <a href="http://jmonkeyengine.org/">JMonkeyEngine</a> и многими другими. Хотя все они являются довольно надежными решениями, если вы хотите создать качественную игру, у каждого есть свои плюсы и минусы, которые вы должны взвесить, прежде чем использовать их, особенно в отношении производительности и масштабируемости.</p>
<p>Мы считаем, Amethyst основан на хороших и современных принципах, что позволит нам создать игровой движок с открытым исходным кодом, который на самом деле будет более производительным, чем эти движки. Эти принципы:</p>
<ol>
<li>
<p><strong>Модульность.</strong></p>
<p>Модульность лежит в основе <a href="https://en.wikipedia.org/wiki/Unix_philosophy">философии Unix</a>, которая с годами зарекомендовала себя как отличный способ разработки программного обеспечения. Вы всегда сможете свободно использовать встроенные модули или написать свои собственные и легко интегрировать их в движок. Поскольку модули малы и хорошо интегрированы, легче рассуждать о том, что они делают и как они связаны с другими модулями.</p>
</li>
</ol>
<ol start="2">
<li>
<p><strong>Параллельность.</strong></p>
<p>Современные компьютеры, даже дешевые, имеют многопоточность с многоядерными процессорами. Мы ожидаем, что с годами у параллелизма будет все больше и больше возможностей для повышения производительности. С помощью правильного параллельного движка мы убеждены, что ваша игра будет становиться все более и более производительной с годами, даже не требуя от вас её обновления.</p>
</li>
<li>
<p><strong>Ориентирование на данные.</strong></p>
<p>Построение вашей игры на основе данных позволяет легко делать прототипы и быстро создавать игры. Сложное поведение, такое как обмен игровыми ресурсами во время игры, становится легким делом, делая тестирование и балансировку намного быстрее.</p>
</li>
</ol>
<h1><a class="header" href="#Зачем-использовать-amethyst" id="Зачем-использовать-amethyst">Зачем использовать Amethyst?</a></h1>
<p>Хотя в экосистеме Rust есть <a href="http://arewegameyet.com/">множество отличных строительных блоков</a>, использование движка Amethyst вместо создания собственного игрового движка, безусловно, имеет много преимуществ.</p>
<p>Прежде всего, движок основан на библиотеке <a href="https://github.com/slide-rs/specs">Specs</a>, которая является основой, на которой строятся концепции движка. Прекрасное введение в разработку игр с помощью Rust и Entity Component System можно найти в этом замечательном <a href="https://kyren.github.io/2018/09/14/rustconf-talk.html">выступлении Кэтрин Уэст</a>. Взгляд Amethyst на ECS описан в разделе книги &quot;Концепции&quot;. Многие функции были связаны воедино.</p>
<p>К примеру, такие как:</p>
<ul>
<li>Трансформации</li>
<li>Графика</li>
<li>Создание окна</li>
<li>Ввод</li>
<li>Аудио</li>
<li>Анимация</li>
<li>Локализация</li>
<li>Сеть</li>
<li>И другие...</li>
</ul>
<p>Если бы вы не использовали Amethyst, вам не только нужно было бы создавать все эти элементы (или использовать уже существующие пакеты), вам также необходимо было бы связать их между собой.</p>
<p>Amethyst делает все это для вас, чтобы вы могли сосредоточиться на создании своей игры, а не беспокоиться о деталях.</p>
<p>Кроме того, благодаря архитектуре Amethyst, почти все части являются настраиваемыми и заменяемыми. Это означает, что если вы хотите что-то изменить в соответствии со своими потребностями, всегда есть способ сделать это.</p>
<p>Например, в настоящее время пакет <a href="https://github.com/tomaka/rodio">rodio</a> используется для функционирования аудио в движке, но если вы предпочитаете использовать какое-то более сложное или нестандартное решение, все, что вам нужно сделать, это организовать передачу данных, поступающих из Specs, в библиотеку которую вы используете для воспроизведения и управления аудио, даже не трогая код движка!</p>
<h1><a class="header" href="#Помощь-в-развитии-amethyst" id="Помощь-в-развитии-amethyst">Помощь в развитии Amethyst</a></h1>
<p>Мы всегда рады приветствовать новых участников!</p>
<p>Чтобы узнать, с чего начать, предлагаем вам ознакомиться с нашими <a href="https://github.com/amethyst/amethyst/blob/master/docs/CONTRIBUTING.md">рекомендациями</a>.</p>
<p>Если вы хотите внести свой вклад или у вас есть вопросы, сообщите нам об этом на <a href="https://github.com/amethyst/amethyst/tree/master">GitHub</a> или <a href="https://discord.gg/amethyst">Discord</a>.</p>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Начало-работы" id="Начало-работы">Начало работы</a></h1>
<h2><a class="header" href="#Настройка-rust" id="Настройка-rust">Настройка Rust</a></h2>
<p>Мы рекомендуем использовать <a href="https://rustup.rs/">rustup</a> для простой установки последней стабильной версии Rust. Инструкции должны быть на экране, как только rustup загрузится.</p>
<p><strong>Обновление Rust:</strong> Если у вас уже установлен Rust, убедитесь, что вы используете последнюю версию, запустив команду:</p>
<blockquote>
<p>&gt; <code>rustup update</code></p>
</blockquote>
<p>Мы рекомендуем использовать стабильную версию Rust, так как Rust Nightly обычно ломаются довольно часто.</p>
<p><strong>Использование стабильной версии:</strong> Rustup можно настроить по умолчанию на стабильную версию, запустив команду:</p>
<blockquote>
<p>&gt; <code>rustup default stable</code></p>
</blockquote>
<h2><a class="header" href="#Требуемые-зависимости" id="Требуемые-зависимости">Требуемые зависимости</a></h2>
<p>Пожалуйста, проверьте раздел зависимостей <a href="https://github.com/amethyst/amethyst/blob/master/README.md#dependencies">README.md</a> для получения подробной информации о том, какие зависимости необходимы для компиляции Amethyst.</p>
<p>Обратите внимание, что вам необходимо установить функциональный графический драйвер. Если вы получаете ошибку из-за того, что средство рендеринга не может создать контекст рендеринга при попытке запустить пример, возможно проблема в неправильной установке драйвера.</p>
<h2><a class="header" href="#Настройка-amethyst" id="Настройка-amethyst">Настройка Amethyst</a></h2>
<p>Вы можете использовать <a href="https://github.com/amethyst/tools">Amethyst CLI</a> или <code>cargo</code> для настройки вашего проекта.</p>
<h3><a class="header" href="#amethyst-cli" id="amethyst-cli">Amethyst CLI</a></h3>
<p>Если вы хотите использовать инструмент Amethyst CLI, вы можете установить его командой:</p>
<blockquote>
<p>&gt; <code>cargo install amethyst_tools</code></p>
</blockquote>
<p>А затем запустить командой:</p>
<blockquote>
<p>&gt; <code>amethyst new name</code></p>
</blockquote>
<p>Вы должны получить папку с файлами <em>Cargo.toml</em>, <em>src/main.rs</em> и <em>config/display.ron</em>.</p>
<h3><a class="header" href="#Стартовый-проект" id="Стартовый-проект">Стартовый проект</a></h3>
<p>Если вы хотите начать экспериментировать с Amethyst как можно быстрее, вы также можете использовать стартовые проекты. Они специально созданы для определенных типов игр и предоставят вам основу, необходимую для немедленного начала.</p>
<p>Файл <em>README.md</em> содержит все, что вам нужно знать для запуска начального проекта.</p>
<blockquote>
<p><strong>Примечание:</strong> прямо сейчас, единственный доступный стартовый проект для 2D-игр. Со временем появиться больше вариантов для разных типов игр.</p>
</blockquote>
<ul>
<li><a href="https://github.com/amethyst/amethyst-starter-2d">2D Starter</a></li>
</ul>
<h3><a class="header" href="#Ручная-настройка" id="Ручная-настройка">Ручная настройка</a></h3>
<p>Если вы используете <code>cargo</code>, вот что вам нужно сделать:</p>
<ul>
<li>Добавьте Amethyst в качестве зависимости в вашем <em>Cargo.toml</em>.</li>
<li>Создайте папку <em>config</em> и поместите в нее <em>display.ron</em>.</li>
<li>(Необязательно) Скопируйте код из одного из примеров аметиста.</li>
</ul>
<h2><a class="header" href="#Важное-замечание-о-версии" id="Важное-замечание-о-версии">Важное замечание о версии</a></h2>
<p>Amethyst делится на две основные версии:</p>
<ul>
<li>Выпущенная версия crates.io, которая является последней версией, доступной на crates.io.</li>
<li>Git (master) версия, которая является текущей неизданной версией разработки Amethyst, доступной на <a href="https://github.com/amethyst/amethyst">Github</a>.</li>
</ul>
<blockquote>
<p><strong>Примечание.</strong> Вы можете узнать, какую версию книги вы просматриваете в настоящий момент, проверив URL в своем браузере. Книга/документация для мастер версии содержит «master» в адресе, версия crates.io называется «стабильной».</p>
</blockquote>
<p>В зависимости от версии книги, которую вы выбрали для чтения, убедитесь, что версия Amethyst в вашем <em>Cargo.toml</em> соответствует этому.</p>
<p>Для выпущенной версии crates.io у вас должно быть что-то вроде этого:</p>
<pre><code class="language-rust ignore">[dependencies]
amethyst = &quot;LATEST_CRATES.IO_VERSION&quot;
</code></pre>
<p>Последнюю версию crates.io можно найти <a href="https://crates.io/crates/amethyst">здесь</a>.</p>
<p>Если вы хотите использовать последние неизданные изменения, ваш файл Cargo.toml должен выглядеть следующим образом:</p>
<pre><code class="language-rust ignore">[dependencies]
amethyst = { git = &quot;https://github.com/amethyst/amethyst&quot;, rev = &quot;COMMIT_HASH&quot; }
</code></pre>
<p>Часть <code>COMMIT_HASH</code> является необязательной. Он указывает, какой конкретный коммит использует ваш проект, чтобы предотвратить непредвиденный сбой при внесении изменений в версию git.</p>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Концепции-лежащие-в-основе-amethyst" id="Концепции-лежащие-в-основе-amethyst">Концепции лежащие в основе Amethyst</a></h1>
<p>Amethyst использует несколько концепций, с которыми вы, возможно, не знакомы. В этом разделе книги объясняется, что они из себя представляют, как они работают и как они связаны друг с другом.</p>
<p>Если вы тот человек, который предпочитает практику и хотите быстро разобраться в коде, вы можете перейти к разделу учебника по понгу, который посвящен практике. Тем не менее, чтение этого раздела предлагается, поскольку может быть трудно понять примеры, не зная теорию, представленную здесь.</p>
<p>Если вы не понимаете, как что-то работает в Amethyst, знание представленных здесь концепций поможет вам понять, как сделаны некоторые реализации.</p>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Состояния" id="Состояния">Состояния</a></h1>
<h2><a class="header" href="#Что-такое-состояние" id="Что-такое-состояние">Что такое состояние?</a></h2>
<p>Слово «состояние» (State) может означать много разных вещей в компьютерной науке. В случае Amethyst оно используется для представления «игрового состояния».</p>
<p>Состояние игры является общей и глобальной частью игры.</p>
<h2><a class="header" href="#Пример" id="Пример">Пример</a></h2>
<p>В качестве примера, скажем, вы делаете игру в понг.</p>
<ul>
<li>Когда пользователь открывает игру, она сначала загружает все ресурсы и показывает экран загрузки.</li>
<li>Затем появляется главное меню с вопросом, хотите ли вы начать игру в одиночном или многопользовательском режиме.</li>
<li>Как только вы выберете одну из опций, игра отобразит ракетки и мяч и начнет играть.</li>
<li>Нажав клавишу escape, вы можете переключиться на меню «пауза».</li>
<li>Как только предел счета достигнут, отображается экран результатов с кнопкой для возврата в главное меню.</li>
</ul>
<p>Игру можно разделить на разные состояния:</p>
<ul>
<li>Загрузка (<code>LoadingState</code>)</li>
<li>Главное меню (<code>MainMenuState</code>)</li>
<li>Игровой процесс (<code>GameplayState</code>)</li>
<li>Пауза (<code>PauseState</code>)</li>
<li>Результаты (<code>ResultState</code>)</li>
</ul>
<p>Мы могли бы эффективно вставить всю игровую логику в одно состояние <code>GameState</code>, разделение его на несколько частей значительно упрощает анализ и поддержку.</p>
<h2><a class="header" href="#Менеджер-состояний" id="Менеджер-состояний">Менеджер состояний</a></h2>
<p>Amethyst имеет встроенный менеджер состояний, который позволяет легко переключаться между различными состояниями. Он основан на концепции автомата с магазинной памятью (<a href="https://ru.wikipedia.org/wiki/%D0%90%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82_%D1%81_%D0%BC%D0%B0%D0%B3%D0%B0%D0%B7%D0%B8%D0%BD%D0%BD%D0%BE%D0%B9_%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D1%8C%D1%8E">pushdown-automaton</a>), который представляет собой комбинацию стека и конечного автомата.</p>
<h3><a class="header" href="#Стек" id="Стек">Стек</a></h3>
<p>Концепция стека позволяет вам «накладывать» состояния друг на друга.</p>
<p>Если мы возьмем пример понга рассмотренный ранее, вы можете вызвать <code>PauseState</code> поверх <code>GameplayState</code>. Когда вы хотите выйти из паузы, вы вытаскиваете <code>PauseState</code> из стека и возвращаетесь в <code>GameplayState</code>, как раз на тот момент, когда вы его покинули.</p>
<h3><a class="header" href="#Конечный-автомат" id="Конечный-автомат">Конечный автомат</a></h3>
<p>Понятие конечного автомата (State Machine) может быть довольно сложным, но здесь мы рассмотрим только его основы.</p>
<p>Конечный автомат обычно состоит из двух элементов: переходов и событий.</p>
<p><strong>Переходы</strong> - это просто «переключение» между двумя состояниями. Например, из <code>LoadingState</code> перейдите в состояние <code>MainMenuState</code>.</p>
<p>Amethyst имеет несколько типов переходов:</p>
<ul>
<li>Вы можете выдвинуть одно состояние поверх другого;</li>
<li>Вы также можете переключить состояние, которое заменяет текущее состояние новым.</li>
</ul>
<p><strong>События</strong> - это то, что вызывает переходы. В случае с Amethyst это разные методы, вызываемые состоянием. Продолжайте читать, чтобы узнать о них.</p>
<h2><a class="header" href="#Жизненный-цикл" id="Жизненный-цикл">Жизненный цикл</a></h2>
<p>Состояния действительны только в течение определенного периода времени, в течение которого может происходить много вещей. Состояние содержит методы, которые вызываются для них, при инициировании событий:</p>
<ul>
<li><code>on_start</code>: когда состояние добавляется в стек;</li>
<li><code>on_stop</code>: когда состояние удаляется из стека;</li>
<li><code>on_pause</code>: когда текущее состояние приостанавливается другим, помещенным поверх состоянием;</li>
<li><code>on_resume</code>: когда приостановленное состояние возобновляется;</li>
<li><code>handle_event</code>: позволяет обрабатывать события (например закрытие окна или нажатие клавиши);</li>
<li><code>fixed_update</code>: вызывается в активном состоянии через фиксированный интервал времени (по умолчанию 1/60 секунды).</li>
<li><code>update</code>: вызывается в активном состоянии, с максимально возможной частотой.</li>
<li><code>shadow_update</code>: вызывается с максимально возможной частотой, для всех состояний, которые находятся в стеке <code>StateMachines</code>, включая активное состояние. В отличие от update, это не возвращает <code>Trans</code>.</li>
<li><code>shadow_fixed_update</code>: вызывается через фиксированный интервал времени (по умолчанию 1/60 секунды) для всех состояний, которые находятся в стеке <code>StateMachines</code>, включая активное состояние. В отличие от <code>fixed_update</code>, это не возвращает <code>Trans</code>.</li>
</ul>
<p>Если вы не используете <code>SimpleState</code> или <code>EmptyState</code>, вы должны реализовать метод <code>update</code> для вызова <code>data.data.update (&amp; mut data.world)</code>.</p>
<h2><a class="header" href="#Данные-игры" id="Данные-игры">Данные игры</a></h2>
<p>Состояния могут иметь произвольные данные, связанные с ними. Если вам нужно хранить данные, которые тесно связаны с вашим состоянием, классический способ - поместить их в структуру состояния.</p>
<p>Состояния также имеют внутренние данные любого типа <code>T</code>. В большинстве случаев используются два следующих: <code>()</code> и <code>GameData</code>.</p>
<ul>
<li><code>()</code> - означает, что нет данных, связанных с этим состоянием. Это обычно используется для тестов, а не для реальных игр.</li>
<li><code>GameData</code> - является стандартом де-факто. Это структура, содержащая <code>Dispatcher</code>. Это будет обсуждаться позже.</li>
</ul>
<p>При вызове методов вашего <code>State</code>, движок будет передавать структуру <code>StateData</code>, которая содержит и <code>World</code> (его обсудим позже), и тип игровых данных, который вы выбрали.</p>
<h2><a class="header" href="#Код" id="Код">Код</a></h2>
<p>Да! Наконец-то пришло время добавить код!</p>
<p>Рассмотрим только небольшой фрагмент кода, который показывает основы использования <code>State</code>. Для более сложных примеров, сотрите главу про создание игры понг.</p>
<h3><a class="header" href="#Создание-состояния" id="Создание-состояния">Создание состояния</a></h3>
<pre><code class="language-rust edition2018 no_run noplaypen">extern crate amethyst;
use amethyst::prelude::*;

struct GameplayState {
    /// Локальные данные состояния. Обычно здесь ничего не будет.
    /// В данном случае, здесь количество игроков.
    player_count: u8,
}

impl SimpleState for GameplayState {
    fn on_start(&amp;mut self, _data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        println!(&quot;Number of players: {}&quot;, self.player_count);
    }
}
</code></pre>
<p>Это действительно много кода!</p>
<p>Сначала мы объявляем структуру состояния <code>GameplayState</code>.</p>
<p>В этом случае мы даем ему некоторые данные: <code>player_count</code>, размером в байт.</p>
<p>Затем мы реализуем типаж <code>SimpleState</code> для нашего <code>GameplayState</code>. <code>SimpleState</code> - это сокращение для <code>State &lt;GameData &lt;'static, 'static&gt;, ()&gt;</code>, где <code>GameData</code> - это внутренние общие данные между состояниями.</p>
<h3><a class="header" href="#Переключение-состояний" id="Переключение-состояний">Переключение состояний</a></h3>
<p>Теперь, если мы хотим перейти во второе состояние, как мы это сделаем?</p>
<p>Что же, нам нужно использовать один из методов, которые возвращают тип <code>Trans</code>. Это:</p>
<ul>
<li><code>handle_event</code></li>
<li><code>fixed_update</code></li>
<li><code>update</code></li>
</ul>
<p>Давайте используем <code>handle_event</code>, чтобы перейти к <code>PausedState</code> и вернуться, нажав клавишу «Escape».</p>
<pre><code class="language-rust edition2018 no_run noplaypen">extern crate amethyst;
use amethyst::prelude::*;
use amethyst::input::{VirtualKeyCode, is_key_down};

struct GameplayState;
struct PausedState;

// На этот раз мы используем () вместо GameData, потому что у нас нет систем, которые нужно обновлять.
// (Они рассматриваются в специальном разделе книги.)
// Вместо того, чтобы писать `State &lt;(), StateEvent&gt;`, мы можем использовать `EmptyState`.

impl EmptyState for GameplayState {
    fn handle_event(&amp;mut self, _data: StateData&lt;()&gt;, event: StateEvent) -&gt; EmptyTrans {
        if let StateEvent::Window(event) = &amp;event {
            if is_key_down(&amp;event, VirtualKeyCode::Escape) {
                // Приостанавливаем игру переходом к `PausedState`.
                return Trans::Push(Box::new(PausedState));
            }
        }

        // Escape не нажат, поэтому мы остаемся в этом состоянии.
        Trans::None
    }
}

impl EmptyState for PausedState {
    fn handle_event(&amp;mut self, _data: StateData&lt;()&gt;, event: StateEvent) -&gt; EmptyTrans {
        if let StateEvent::Window(event) = &amp;event {
            if is_key_down(&amp;event, VirtualKeyCode::Escape) {
                // Возвращаемся обратно к `GameplayState`.
                return Trans::Pop;
            }
        }

        // Escape не нажат, поэтому мы остаемся в этом состоянии.
        Trans::None
    }
}
</code></pre>
<h3><a class="header" href="#Обработка-событий" id="Обработка-событий">Обработка событий</a></h3>
<p>Как вы уже видели, мы можем обрабатывать события из метода <code>handle_event</code>. Но что это за странный <code>StateEvent</code>?</p>
<p>Ну, это просто перечисление. Оно группирует несколько типов событий, которые по умолчанию генерируются во всем движке. Чтобы изменить набор событий, которые получает состояние, вы создаете новое перечисление событий и извлекаете <code>EventReader</code> для этого типа.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">#[macro_use] extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::ui::UiEvent;
</span><span class="boring">use amethyst::input::{VirtualKeyCode, is_key_down};
</span><span class="boring">use amethyst::winit::Event;
</span>
// Эти импорты требуются #[derive(EventReader)] для сборки кода
use amethyst::core::{
    ecs::{Read, SystemData, World},
    shrev::{ReaderId, EventChannel},
    EventReader
};

#[derive(Clone, Debug)]
pub struct AppEvent {
    data: i32,
}

#[derive(Debug, EventReader, Clone)]
#[reader(MyEventReader)]
pub enum MyEvent {
    Window(Event),
    Ui(UiEvent),
    App(AppEvent),
}

struct GameplayState;

impl State&lt;(), MyEvent&gt; for GameplayState {
    fn handle_event(&amp;mut self, _data: StateData&lt;()&gt;, event: MyEvent) -&gt; Trans&lt;(), MyEvent&gt; {
        match event {
            // События, связанные с окном и вводом.
            MyEvent::Window(_) =&gt; {},
            // Ui событие. Нажатие кнопок, наведение мыши и т.д ...
            MyEvent::Ui(_) =&gt; {},
            MyEvent::App(ev) =&gt; println!(&quot;Got an app event: {:?}&quot;, ev),
        };

        Trans::None
    }
}

<span class="boring">fn main() {}
</span></code></pre>
<p>Чтобы приложение узнало об изменении событий, отправляемых в состояние, вам также необходимо указать и тип события, и тип <code>EventReader</code> (имя, которое вы даете в атрибуте <code>#[reader(SomeReader)]</code>), когда приложение создано. Это делается путем замены <code>Application::build</code> (или <code>Application::new</code>) на <code>CoreApplication::&lt;\_, MyEvent, MyEventReader&gt;::build()</code> (или <code>CoreApplication::&lt;\_, MyEvent, MyEventReader&gt;::new()</code>) ,</p>
<p>Примечание. События собираются из <code>EventChannels</code>. <code>EventChannels</code> описаны в отдельном разделе книги.</p>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Сущность-и-компонент" id="Сущность-и-компонент">Сущность и компонент</a></h1>
<h2><a class="header" href="#Что-такое-entity-и-component" id="Что-такое-entity-и-component">Что такое <code>Entity</code> и <code>Component</code>?</a></h2>
<p>Сущность (<code>Entity</code>) представляет один объект в вашем мире. Компонент (<code>Component</code>) представляет один аспект объекта. Например, бутылка воды имеет форму, объем, цвет и изготовлена ​​из материала (обычно из пластика). В этом примере бутылка - это сущность, а свойства - это компоненты.</p>
<h2><a class="header" href="#Сущность-и-компонент-в-amethyst" id="Сущность-и-компонент-в-amethyst">Сущность и компонент в Amethyst</a></h2>
<p>В дизайне наследования, сущность обычно содержит компоненты. Все данные и методы, связанные с сущностью, хранятся внутри. Однако в проекте ECS сущность является просто объектом общего назначения. На самом деле реализация <code>Entity</code> в Amethyst - это просто:</p>
<pre><code class="language-rust ignore">struct Entity(u32, Generation);
</code></pre>
<p>Где <code>u32</code> - идентификатор объекта, а <code>Generation</code> используется для проверки была ли удалена сущность.</p>
<p><code>Entity</code> хранятся в специальном контейнере <code>EntitiesRes</code>. Принимая во внимание, что данные, связанные с объектами, группируются в компоненты и хранятся в назначенных хранилищах.</p>
<p>Рассмотрим пример, где у вас есть три объекта: две бутылки и человек.</p>
<table><thead><tr><th align="center">object</th><th align="center">x</th><th align="center">y</th><th align="center">shape</th><th align="center">color</th><th align="center">name</th></tr></thead><tbody>
<tr><td align="center">Bottle A</td><td align="center">150.0</td><td align="center">202.1</td><td align="center">&quot;round&quot;</td><td align="center">&quot;red&quot;</td><td align="center"></td></tr>
<tr><td align="center">Bottle B</td><td align="center">570.0</td><td align="center">122.0</td><td align="center">&quot;square&quot;</td><td align="center">&quot;white&quot;</td><td align="center"></td></tr>
<tr><td align="center">Person C</td><td align="center">100.5</td><td align="center">300.8</td><td align="center"></td><td align="center"></td><td align="center">&quot;Peter&quot;</td></tr>
</tbody></table>
<p>Мы можем разделить свойства бутылки на <code>PositionComponent</code> и <code>BottleComponent</code>, а свойства человека на <code>PositionComponent</code> и <code>PersonComponent</code>. Вот иллюстрация того, как будут храниться три объекта.</p>
<p><img src="concepts/..%5Cimages%5Cchapter_3_part_2.png" alt="alt text" /></p>
<p>Как видно из графика, сущности не хранят данные. Они также не знают никакой информации о своих компонентах. Они служат для идентификации объекта и отслеживания существования объекта. Хранилище компонентов хранит все данные и их связь с сущностями.</p>
<p>Если вы знакомы с реляционными базами данных, эта организация выглядит очень похоже на таблицы в базе данных, где идентификатор сущности служит ключом в каждой таблице. На самом деле, вы даже можете объединять компоненты или сущности, также как объединяете таблицы. Например, чтобы обновить положение всех людей, вам нужно соединить <code>PersonComponent</code> и <code>PositionComponent</code>.</p>
<h2><a class="header" href="#entitiesres" id="entitiesres">EntitiesRes</a></h2>
<p>Хотя структура сущности довольно проста, манипуляции с сущностями очень сложны и имеют решающее значение для производительности игры. Вот почему сущности обрабатываются исключительно структурой <code>EntitiesRes</code>. <code>EntitiesRes</code> предоставляет два способа создания/удаления объектов:</p>
<ul>
<li>Немедленное создание/удаление, используется для настройки игры или очистки.</li>
<li>Ленивое создание/удаление, используется в игровом состоянии. Он обновляет сущности в пакете в конце каждого игрового цикла. Это также называется атомарным созданием/удалением.</li>
</ul>
<p>Вы увидите, как эти методы используются в следующих главах.</p>
<h2><a class="header" href="#Объявление-компонента" id="Объявление-компонента">Объявление компонента</a></h2>
<p>Чтобы объявить компонент, вы сначала объявляете соответствующие базовые данные:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">/// Этот `Component` описывает форму `Entity`
enum Shape {
    Sphere { radius: f32 },
    Cuboid { height: f32, width: f32, depth: f32 },
}

/// Этот `Component` описывает преобразование `Entity`
pub struct Transform {
    /// Значение сдвиг + вращение
    iso: Isometry3&lt;f32&gt;,
    /// Вектор масштаба
    scale: Vector3&lt;f32&gt;,
}
</code></pre>
<p>А затем реализуете для них типаж <code>Component</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">use amethyst::ecs::{Component, DenseVecStorage, FlaggedStorage};

impl Component for Shape {
    type Storage = DenseVecStorage&lt;Self&gt;;
}

impl Component for Transform {
    type Storage = FlaggedStorage&lt;Self, DenseVecStorage&lt;Self&gt;&gt;;
}
</code></pre>
<p>Тип хранилища будет определять способ хранения компонента, но не инициализировать хранилище. Хранилище инициализируется при регистрации компонента в <code>World</code> или при использовании этого компонента в <code>System</code>.</p>
<h2><a class="header" href="#Хранилища" id="Хранилища">Хранилища</a></h2>
<p>Существует несколько стратегий хранения для различных сценариев использования. Наиболее часто используемые типы - <code>DenseVecStorage</code>, <code>VecStorage</code> и <code>FlaggedStorage</code>.</p>
<ul>
<li><code>DenseVecStorage</code>: Элементы хранятся в непрерывном векторе. Между компонентами не остается пустого пространства, что позволяет уменьшить использование памяти для больших компонентов.</li>
<li><code>VecStorage</code>: Элементы хранятся в разреженном массиве. Идентификатор объекта совпадает с индексом компонента. Если ваш компонент небольшой (&lt;= 16 байт) или поддерживается большинством объектов, это предпочтительнее, чем <code>DenseVecStorage</code>.</li>
<li><code>FlaggedStorage</code>: Используется для отслеживания изменений компонента. Полезно для кэширования.</li>
</ul>
<!-- DenseVec Storage Diagram Table -->
<div style="width: 100%">
    <h4 style="text-align: center; font-weight: bold">DenseVecStorage ( <em>entity_id</em> сопоставляет с <em>data_id</em> )</h4>
    <div style="display: flex">
        <div style="margin-right: 3em">
            <table style="text-align: center;">
                <tr><td style="background-color: #D8E5FD; color: black;">data</td></tr>
                <tr><td style="background-color: #D8E5FD; color: black;">data_id</td></tr>
                <tr><td style="background-color: #D8E5FD; color: black;">entity_id</td></tr>
            </table>
        </div>
        <div style="flex-grow: 1; text-align: center">
            <table style="width: 100%">
                <tr>
                    <td>data</td>
                    <td>data</td>
                    <td>data</td>
                    <td>data</td>
                    <td>...</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>2</td>
                    <td>3</td>
                    <td>1</td>
                    <td>...</td>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1</td>
                    <td>5</td>
                    <td>9</td>
                    <td>...</td>
                </tr>
            </table>
        </div>
</div>
<!-- VecStorage Diagram Table -->
<div style="width: 100%">
    <h4 style="text-align: center; font-weight: bold">VecStorage ( <em>entity_id</em> = индекс данных, может быть пустым )</h4>
    <div style="display: flex">
        <div style="margin-right: 3em">
            <table><tr><td style="background-color: #D8E5FD; color: black;">data</td></tr></table>
        </div>
        <div style="flex-grow: 1; text-align: center">
            <table style="width: 100%">
                <tr>
                    <td>data</td>
                    <td>data</td>
                    <td style="background-color: #E22C2C99; color: black;">empty</td>
                    <td>data</td>
                    <td>...</td>
                </tr>
            </table>
        </div>
</div>
<p>Для получения дополнительной информации см. <a href="https://docs.rs/specs/0.16.1/specs/storage/index.html">specs::storage</a> и <a href="https://specs.amethyst.rs/docs/tutorials/05_storages.html">раздел «Хранилища»</a> книги specs.</p>
<p>Существует множество других хранилищ, и решение о том, какое из них лучше, не тривиально и должно быть сделано на основе тщательного бенчмаркинга. Общее правило: если ваш компонент используется более чем в 30% объектов, используйте <code>VecStorage</code>. Если вы не знаете, какой из них следует использовать, <code>DenseVecStorage</code> будет хорошим вариантом по умолчанию. Ему потребуется больше памяти, чем <code>VecStorage</code> для указателей размера компонентов, но он будет работать хорошо для большинства сценариев.</p>
<h2><a class="header" href="#Теги" id="Теги">Теги</a></h2>
<p>Компоненты также могут быть использованы для «маркировки» объектов. Обычный способ сделать это - создать пустую структуру и реализовать <code>Component</code>, используя <code>NullStorage</code> в качестве типа хранилища для него. Нулевое хранилище означает, что для хранения этих компонентов не потребуется пространство памяти.</p>
<p>Вы узнаете, как использовать эти компоненты тегов в главе «Система».</p>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Ресурс" id="Ресурс">Ресурс</a></h1>
<h2><a class="header" href="#Что-такое-ресурс" id="Что-такое-ресурс">Что такое ресурс?</a></h2>
<p>Ресурс - это любой тип, в котором хранятся данные, которые могут вам понадобиться для вашей игры, и которые не относятся к конкретной сущности. Например, счет игры в понг является глобальным для всей игры и не принадлежит ни одной из сущностей (ракетка, мяч и даже текст количества очков в пользовательском интерфейсе).</p>
<h2><a class="header" href="#Создание-ресурса" id="Создание-ресурса">Создание ресурса</a></h2>
<p>Ресурсы хранятся в контейнере <code>World</code>. Добавление ресурса в экземпляр <code>World</code> производится следующим образом:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::ecs::World;

struct MyResource {
    pub game_score: i32,
}

fn main() {
    let mut world = World::empty();

    let my = MyResource {
        game_score: 0,
    };

    world.insert(my);
}
</code></pre>
<h2><a class="header" href="#Получение-ресурса-из-world" id="Получение-ресурса-из-world">Получение ресурса (из <code>World</code>)</a></h2>
<p>Извлечение ресурса может быть сделано так:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">#[derive(Debug, PartialEq)]
</span><span class="boring">struct MyResource {
</span><span class="boring">  pub game_score: i32,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::empty();
</span><span class="boring">  let my = MyResource{
</span><span class="boring">    game_score: 0,
</span><span class="boring">  };
</span><span class="boring">  world.insert(my);
</span>  // try_fetch возвращает тип Option&lt;Fetch&lt;MyResource&gt;&gt;.
  let fetched = world.try_fetch::&lt;MyResource&gt;();
  if let Some(fetched_resource) = fetched {
      // Разыменование Fetch&lt;MyResource&gt; для доступа к данным.
      assert_eq!(*fetched_resource, MyResource{ game_score: 0, });
  } else {
      println!(&quot;No MyResource present in `World`&quot;);
  }
<span class="boring">}
</span></code></pre>
<p>Если вы хотите получить ресурс или создать его, если он не существует:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">struct MyResource;
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::empty();
</span>    let my = MyResource;
  // Если ресурс не внутри `World`,
  // он вставит экземпляр, который мы создали.
let fetched = world.entry::&lt;MyResource&gt;().or_insert_with(|| my);
<span class="boring">}
</span></code></pre>
<p>Если вы хотите изменить ресурс, который уже находится внутри <code>World</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">struct MyResource {
</span><span class="boring">  pub game_score: i32,
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::empty();
</span><span class="boring">  let my = MyResource{
</span><span class="boring">    game_score: 0,
</span><span class="boring">  };
</span><span class="boring">  world.insert(my);
</span>  // try_fetch_mut возвращает Option&lt;FetchMut&lt;MyResource&gt;&gt;.
  let fetched = world.try_fetch_mut::&lt;MyResource&gt;();
  if let Some(mut fetched_resource) = fetched {
    assert_eq!(fetched_resource.game_score, 0);
    fetched_resource.game_score = 10;
    assert_eq!(fetched_resource.game_score, 10);
  } else {
    println!(&quot;No MyResource present in `World`&quot;);
  }
<span class="boring">}
</span></code></pre>
<p>Другие способы получения ресурса будут рассмотрены в разделе книги &quot;Система&quot;.</p>
<h2><a class="header" href="#Удаление-ресурса" id="Удаление-ресурса">Удаление ресурса</a></h2>
<p>Нет способа правильно «удалить» ресурс, добавленный в мир. Обычный метод для достижения чего-то похожего - это добавить <code>Option&lt;MyResource&gt;</code> и установить его в <code>None</code>, когда вы хотите удалить его.</p>
<h2><a class="header" href="#Хранилища-часть-2" id="Хранилища-часть-2">Хранилища, часть 2</a></h2>
<p><code>Storage</code> компонента - это ресурс. Компоненты «привязаны» к объектам, но, как было сказано ранее, они не «принадлежат» объектам на уровне реализации. Храня их в хранилищах и размещая <code>Storage</code> внутри <code>World</code>, он обеспечивает глобальный доступ ко всем компонентам во время выполнения с минимальными усилиями.</p>
<p>Фактический доступ к компонентам внутри хранилищ будет описан в разделах книги &quot;Мир&quot; и &quot;Система&quot;.</p>
<p><strong>ВНИМАНИЕ:</strong> Если вы попытаетесь получить компонент напрямую, вы не получите хранилище. Вы получите экземпляр <code>Default::default()</code> этого компонента. Чтобы получить ресурс <code>Storage</code>, в котором хранятся все экземпляры <code>MyComponent</code>, необходимо извлечь <code>ReadStorage&lt;MyComponent&gt;</code>.</p>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Мир" id="Мир">Мир</a></h1>
<h2><a class="header" href="#Что-такое-мир" id="Что-такое-мир">Что такое мир?</a></h2>
<p>Мир (<code>World</code>) - это контейнер для ресурсов с некоторыми вспомогательными функциями, которые облегчают вашу жизнь. Эта глава продемонстрирует эти функции и их использование.</p>
<h2><a class="header" href="#Добавление-ресурса" id="Добавление-ресурса">Добавление ресурса</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::ecs::{World, WorldExt};

// Простая структура без данных.
struct MyResource;

fn main() {
    // Мы создали новый экземпляр `World`.
    let mut world = World::new();

    // Мы создали наш ресурс.
    let my = MyResource;

    // Мы добавили ресурс в наш мир.
    world.insert(my);
}
</code></pre>
<h2><a class="header" href="#Извлечение-ресурса" id="Извлечение-ресурса">Извлечение ресурса</a></h2>
<p>Вот как можно получить ресурс только для чтения. Помните, что этот метод вызывает панику, если ресурс не присутствует в <code>Resources</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyResource;
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    let my = world.read_resource::&lt;MyResource&gt;();
<span class="boring">}
</span></code></pre>
<p>Если вы не уверены, что ресурс присутствует, используйте методы, доступные в <code>Resources</code>, как показано в главе, посвященной ресурсам.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyResource;
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    let my = world.entry::&lt;MyResource&gt;().or_insert_with(|| MyResource);
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#Модификация-ресурса" id="Модификация-ресурса">Модификация ресурса</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyResource;
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    let mut my = world.write_resource::&lt;MyResource&gt;();
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#Создание-сущностей" id="Создание-сущностей">Создание сущностей</a></h2>
<p>Сначала вы создаете построитель сущностей. Затем вы можете добавить компоненты к вашей сущности. Наконец, вы вызываете метод <code>build()</code> для построителя сущностей, чтобы получить данную сущность.</p>
<p><strong>Обратите внимание.</strong> Для использования этого синтаксиса вам необходимо импортировать типаж <code>amethyst::prelude::Builder</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    world.register::&lt;MyComponent&gt;();
    use amethyst::prelude::Builder;

    let mut entity_builder = world.create_entity();
    entity_builder = entity_builder.with(MyComponent);
    let my_entity = entity_builder.build();
<span class="boring">}
</span></code></pre>
<p>Короткая версия:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    use amethyst::prelude::Builder;

    let my_entity = world
       .create_entity()
       .with(MyComponent)
       .build();
<span class="boring">}
</span></code></pre>
<p>Внутренне <code>World</code> взаимодействует с <code>EntitiesRes</code>, который является ресурсом, содержащим сущности внутри <code>Resources</code>.</p>
<h2><a class="header" href="#Доступ-к-component" id="Доступ-к-component">Доступ к <code>Component</code></a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    // Создаём `Entity` с `MyComponent`.
    // `World` будет неявно записывать в хранилище компонента в `Resources`.
    let my_entity = world.create_entity().with(MyComponent).build();

    // Получаем ReadStorage&lt;MyComponent&gt;
    let storage = world.read_storage::&lt;MyComponent&gt;();

    // Получаем наш компонент из хранилища.
    let my = storage.get(my_entity).expect(&quot;Failed to get component for entity&quot;);
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#Изменение-component" id="Изменение-component">Изменение <code>Component</code></a></h2>
<p>Это почти то же самое, что и доступ к компоненту:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    let my_entity = world.create_entity().with(MyComponent).build();
    let mut storage = world.write_storage::&lt;MyComponent&gt;();
    let mut my = storage.get_mut(my_entity).expect(&quot;Failed to get component for entity&quot;);
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#Получение-всех-сущностей" id="Получение-всех-сущностей">Получение всех сущностей</a></h2>
<p>Это довольно редко используется, но может быть полезно в некоторых случаях.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    // Возвращает `EntitiesRes`.
    let entities = world.entities();
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#Удалить-сущность" id="Удалить-сущность">Удалить сущность</a></h2>
<p>Одину:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span><span class="boring">  let my_entity = world.create_entity().build();
</span>    world.delete_entity(my_entity).expect(&quot;Failed to delete entity. Was it already removed?&quot;);
<span class="boring">}
</span></code></pre>
<p>Несколько:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span><span class="boring">  let entity_vec: Vec&lt;amethyst::ecs::Entity&gt; = vec![world.create_entity().build()];
</span>    world.delete_entities(entity_vec.as_slice()).expect(&quot;Failed to delete entities from specified list.&quot;);
<span class="boring">}
</span></code></pre>
<p>Все:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    world.delete_all();
<span class="boring">}
</span></code></pre>
<p><strong>Примечание.</strong> Объекты удаляются лениво, что означает, что удаление происходит только в конце кадра, а не сразу при вызове метода удаления.</p>
<h2><a class="header" href="#Проверка-была-ли-сущность-удалена" id="Проверка-была-ли-сущность-удалена">Проверка, была ли сущность удалена</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Builder, World, WorldExt};
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span><span class="boring">  let my_entity = world.create_entity().build();
</span>    // Возвращает true если сущность НЕ удалена.
    let is_alive = world.is_alive(my_entity);
<span class="boring">}
</span></code></pre>
<h2><a class="header" href="#exec" id="exec">Exec</a></h2>
<p>Эта часть просто чтобы показать, что эта функция существует. Это нормально, не понимать, что она делает, пока вы не прочитаете главу &quot;Система&quot;. Иногда вам может понадобиться создать объект, для которого вам нужно получить ресурсы, чтобы создать для него правильные компоненты. Есть функция, которая действует как сокращение для этого:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{ReadExpect, World, WorldExt};
</span><span class="boring">struct Dummy;
</span><span class="boring">type SomeSystemData&lt;'a&gt; = ReadExpect&lt;'a, Dummy&gt;;
</span><span class="boring">trait DoSomething {
</span><span class="boring">  fn do_something(&amp;mut self);
</span><span class="boring">}
</span><span class="boring">impl&lt;'a&gt; DoSomething for SomeSystemData&lt;'a&gt; {
</span><span class="boring">  fn do_something(&amp;mut self) { }
</span><span class="boring">}
</span><span class="boring">fn main() {
</span><span class="boring">  let mut world = World::new();
</span>    world.exec(|mut data: SomeSystemData| {
        data.do_something();
    });
<span class="boring">}
</span></code></pre>
<p>Мы поговорим о том, что такое <code>SystemData</code>, в главе &quot;Система&quot;.</p>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Система" id="Система">Система</a></h1>
<h2><a class="header" href="#Что-такое-система" id="Что-такое-система">Что такое система?</a></h2>
<p>Система (<code>System</code>) - это место, где выполняется логика игры. На практике система состоит из структуры, реализующей функцию, выполняемую на каждой итерации игрового цикла, и принимающей в качестве аргумента данные об игре. Системы можно рассматривать как маленькую единицу логики. Все системы запускаются движком вместе (даже параллельно, когда это возможно) и выполняют специализированную операцию с одной или группой сущностей.</p>
<p>Структура</p>
<p>Структура системы - это структура, реализующая типаж amethyst::ecs::System. Вот очень простой пример реализации:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::System;
</span>struct MyFirstSystem;

impl&lt;'a&gt; System&lt;'a&gt; for MyFirstSystem {
    type SystemData = ();

    fn run(&amp;mut self, data: Self::SystemData) {
        println!(&quot;Hello!&quot;);
    }
}
</code></pre>
<p>Эта система будет на каждой итерации игрового цикла выводить «Hello!» в консоли. Это довольно скучная система, поскольку она вообще не взаимодействует с игрой. Давайте немного оживим это.</p>
<p>Доступ к контексту игры</p>
<p>В определении системы этот типаж требует от вас определения типа <code>SystemData</code>. Этот тип определяет, какие данные будут предоставляться системой при каждом вызове метода <code>run</code>. <code>SystemData</code> предназначен только для переноса информации, доступной для нескольких систем. Данные, локальные для системы, обычно хранятся в самой структуре системы.</p>
<p>Движок Amethyst предоставляет полезные системные типы данных для доступа к контексту игры. Вот некоторые из наиболее важных:</p>
<ul>
<li><code>Read&lt;'a, Resource&gt;</code> (или <code>Write&lt;'a, Resource&gt;</code> соответственно) позволяет вам получить неизменяемую (или соответственно изменяемую) ссылку на ресурс указанного вами типа. Это гарантированно не завершится сбоем, так как если ресурс недоступен, он даст вам <code>Default::default()</code> вашего ресурса.</li>
<li><code>ReadExpect&lt;'a, Resource&gt;</code> (или <code>WriteExpect&lt;'a, Resource&gt;</code> соответственно) является отказоустойчивой альтернативой предыдущему типу, поэтому вы можете использовать ресурсы, которые не реализуют типаж <code>Default</code>.</li>
<li><code>ReadStorage&lt;'a, Component&gt;</code> (или <code>WriteStorage&lt;'a, Component&gt;</code> соответственно) позволяет получить неизменяемую (или соответственно изменяемую) ссылку на всё хранилище определенного типа <code>Component</code>.</li>
<li><code>Entities&lt;'a&gt;</code> позволяет вам создавать или уничтожать сущности в контексте системы.</li>
</ul>
<p>Затем вы можете использовать один или несколько из них с помощью кортежа.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, Read};
</span><span class="boring">use amethyst::core::timing::Time;
</span>struct MyFirstSystem;

impl&lt;'a&gt; System&lt;'a&gt; for MyFirstSystem {
    type SystemData = Read&lt;'a, Time&gt;;

    fn run(&amp;mut self, data: Self::SystemData) {
        println!(&quot;{}&quot;, data.delta_seconds());
    }
}
</code></pre>
<p>Здесь мы получаем ресурс <code>amethyst::core::timer::Time</code> для печати в консоль времени, прошедшего между двумя кадрами. Хорошо! Но это все еще немного скучно.</p>
<h2><a class="header" href="#Манипуляции-с-хранилищами" id="Манипуляции-с-хранилищами">Манипуляции с хранилищами</a></h2>
<p>Получив доступ к хранилищу, вы можете использовать их по-разному.</p>
<h3><a class="header" href="#Получение-компонента-конкретной-сущности" id="Получение-компонента-конкретной-сущности">Получение компонента конкретной сущности</a></h3>
<p>Иногда бывает полезно получить компонент конкретной сущности из хранилища. Это легко сделать с помощью метода <code>get</code> или, для изменяемых хранилищ, метода <code>get_mut</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Entity, System, WriteStorage};
</span><span class="boring">use amethyst::core::Transform;
</span>struct WalkPlayerUp {
    player: Entity,
}

impl&lt;'a&gt; System&lt;'a&gt; for WalkPlayerUp {
    type SystemData = WriteStorage&lt;'a, Transform&gt;;

    fn run(&amp;mut self, mut transforms: Self::SystemData) {
        transforms.get_mut(self.player).unwrap().prepend_translation_y(0.1);
    }
}
</code></pre>
<p>Эта система заставляет игрока подниматься на 0,1 единицы за каждую итерацию игрового цикла! Чтобы определить, что это за игрок, мы заранее сохранили его в структуре системы. Затем мы получаем его <code>Transform</code> из хранилища <code>Transform</code> и перемещаем его вдоль оси Y на 0,1.</p>
<blockquote>
<p><code>Transform</code> - очень распространенная структура в разработке игр. Она представляет положение, вращение и масштаб объекта в игровом мире. Вы будете использовать их очень часто, так как они - то, что вам нужно изменить, когда вы хотите что-то изменить в своей игре.</p>
</blockquote>
<p>Однако такой подход довольно редок, потому что большую часть времени вы не знаете, какой сущностью вы хотите манипулировать, и чаще вы будете применить свои изменения к нескольким сущностям.</p>
<h3><a class="header" href="#Получение-всех-сущностей-с-конкретными-компонентами" id="Получение-всех-сущностей-с-конкретными-компонентами">Получение всех сущностей с конкретными компонентами</a></h3>
<p>В большинстве случаев вы захотите выполнить логику для всех сущностей с определенным компонентом или даже для всех сущностей с набором компонентов.</p>
<p>Это возможно с помощью метода <code>join</code>. Возможно, вы знакомы с операциями объединения, если вы когда-либо работали с базами данных. Метод <code>join</code> принимает несколько хранилищ и выполняет итерацию по всем сущностям, которые имеют компонент в каждом из этих хранилищ. Это работает как &quot;И&quot; ворота. Он вернет итератор, содержащий кортеж всех запрошенных компонентов, если они <strong>все</strong> на одной и той же сущности.</p>
<p>Если вы используете 'join' c компонентами A, B и C, будут рассматриваться только те объекты, которые имеют ВСЕ эти компоненты.</p>
<p>Само собой разумеется, что вы можете использовать его только с одним хранилищем для перебора всех объектов с определенным компонентом.</p>
<p>Помните, что метод <code>join</code> доступен только при импорте <code>amethyst::ecs::Join</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, ReadStorage, WriteStorage};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">struct FallingObject;
</span><span class="boring">impl amethyst::ecs::Component for FallingObject {
</span><span class="boring">  type Storage = amethyst::ecs::DenseVecStorage&lt;FallingObject&gt;;
</span><span class="boring">}
</span>use amethyst::ecs::Join;

struct MakeObjectsFall;

impl&lt;'a&gt; System&lt;'a&gt; for MakeObjectsFall {
    type SystemData = (
        WriteStorage&lt;'a, Transform&gt;,
        ReadStorage&lt;'a, FallingObject&gt;,
    );

    fn run(&amp;mut self, (mut transforms, falling): Self::SystemData) {
        for (mut transform, _) in (&amp;mut transforms, &amp;falling).join() {
            if transform.translation().y &gt; 0.0 {
                transform.prepend_translation_y(-0.1);
            }
        }
    }
}
</code></pre>
<p>Эта система найдёт все сущности которым принадлежат оба компонента. Компонент <code>Transform</code> с положительной координатой <code>y</code> и компонент тег <code>FallingObject</code>. И уменьшит их координату <code>y</code> на 0,1 единицу за итерацию игрового цикла. Обратите внимание, что поскольку <code>FallingObject</code> присутствует здесь только в качестве тега для ограничения операции объединения (<code>join</code>), мы немедленно отбрасываем его, используя синтаксис <code>\_</code>.</p>
<p>Здорово! Теперь это похоже на то, что мы действительно будем делать в наших играх!</p>
<h3><a class="header" href="#Получение-сущностей-которые-имеют-некоторые-компоненты-но-не-другие" id="Получение-сущностей-которые-имеют-некоторые-компоненты-но-не-другие">Получение сущностей, которые имеют некоторые компоненты, но не другие</a></h3>
<p>В спецификациях есть специальный тип хранилища, называемый <code>AntiStorage</code>. Оператор <em>not</em> (<code>!</code>) превращает хранилище в его аналог <code>AntiStorage</code>, что позволяет перебирать объекты, которые <em>не</em> имеют этот компонент.</p>
<p>Используется так:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, ReadStorage, WriteStorage};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">struct FallingObject;
</span><span class="boring">impl amethyst::ecs::Component for FallingObject {
</span><span class="boring">  type Storage = amethyst::ecs::DenseVecStorage&lt;FallingObject&gt;;
</span><span class="boring">}
</span>use amethyst::ecs::Join;

struct NotFallingObjects;

impl&lt;'a&gt; System&lt;'a&gt; for NotFallingObjects {
    type SystemData = (
        WriteStorage&lt;'a, Transform&gt;,
        ReadStorage&lt;'a, FallingObject&gt;,
    );

    fn run(&amp;mut self, (mut transforms, falling): Self::SystemData) {
        for (mut transform, _) in (&amp;mut transforms, !&amp;falling).join() {
            // Если они не падают, почему бы не заставить их подняться!
            transform.prepend_translation_y(0.1);
        }
    }
}
</code></pre>
<h2><a class="header" href="#Управление-структурой-сущностей" id="Управление-структурой-сущностей">Управление структурой сущностей</a></h2>
<p>Иногда может быть полезно манипулировать структурой сущностей в системе, например, создавать новые или модифицировать компоновку существующих компонентов. Этот процесс выполняется с использованием системных данных <code>Entities &lt;'a&gt;</code>.</p>
<blockquote>
<p>Запрос <code>Entities&lt;'a&gt;</code> не влияет на производительность, поскольку он содержит только неизменяемые ресурсы и, следовательно, <a href="https://book-src.amethyst.rs/stable/concepts/dispatcher.html">не блокирует диспетчеризацию</a>.</p>
</blockquote>
<h3><a class="header" href="#Создание-новых-сущностей-в-системе" id="Создание-новых-сущностей-в-системе">Создание новых сущностей в системе</a></h3>
<p>Создание сущности в контексте системы очень похоже на способ создания сущности с использованием структуры <code>World</code>. Единственное отличие состоит в том, что необходимо обеспечить изменяемые хранилища всех компонентов, которые вы планируете добавить в сущность.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, WriteStorage, Entities};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">struct Enemy;
</span><span class="boring">impl amethyst::ecs::Component for Enemy {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Enemy&gt;;
</span><span class="boring">}
</span>struct SpawnEnemies {
    counter: u32,
}

impl&lt;'a&gt; System&lt;'a&gt; for SpawnEnemies {
    type SystemData = (
        WriteStorage&lt;'a, Transform&gt;,
        WriteStorage&lt;'a, Enemy&gt;,
        Entities&lt;'a&gt;,
    );

    fn run(&amp;mut self, (mut transforms, mut enemies, entities): Self::SystemData) {
        self.counter += 1;
        if self.counter &gt; 200 {
            entities.build_entity()
                .with(Transform::default(), &amp;mut transforms)
                .with(Enemy, &amp;mut enemies)
                .build();
            self.counter = 0;
        }
    }
}
</code></pre>
<p>Эта система будет порождать нового врага каждые 200 итераций игрового цикла.</p>
<h3><a class="header" href="#Удаление-сущности" id="Удаление-сущности">Удаление сущности</a></h3>
<p>Удалить сущность очень легко, используя <code>Entities &lt;'a&gt;</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, Entities, Entity};
</span><span class="boring">struct MySystem { entity: Entity }
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MySystem {
</span><span class="boring">  type SystemData = Entities&lt;'a&gt;;
</span><span class="boring">  fn run(&amp;mut self, entities: Self::SystemData) {
</span><span class="boring">      let entity = self.entity;
</span>entities.delete(entity);
<span class="boring">  }
</span><span class="boring">}
</span></code></pre>
<h3><a class="header" href="#Перебор-компонентов-со-связанной-сущностью" id="Перебор-компонентов-со-связанной-сущностью">Перебор компонентов со связанной сущностью</a></h3>
<p>Иногда, когда вы перебираете компоненты, вы также можете узнать, с какой сущностью вы работаете. Для этого вы можете использовать операцию <code>join</code> с <code>Entities &lt;'a&gt;</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{Join, System, Entities, WriteStorage, ReadStorage};
</span><span class="boring">use amethyst::core::Transform;
</span><span class="boring">struct FallingObject;
</span><span class="boring">impl amethyst::ecs::Component for FallingObject {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;FallingObject&gt;;
</span><span class="boring">}
</span>struct MakeObjectsFall;

impl&lt;'a&gt; System&lt;'a&gt; for MakeObjectsFall {
    type SystemData = (
        Entities&lt;'a&gt;,
        WriteStorage&lt;'a, Transform&gt;,
        ReadStorage&lt;'a, FallingObject&gt;,
    );

    fn run(&amp;mut self, (entities, mut transforms, falling): Self::SystemData) {
        for (e, mut transform, _) in (&amp;*entities, &amp;mut transforms, &amp;falling).join() {
            if transform.translation().y &gt; 0.0 {
                transform.prepend_translation_y(-0.1);
            } else {
                entities.delete(e);
            }
        }
    }
}
</code></pre>
<p>Эта система делает то же самое, что и предыдущая <code>MakeObjectsFall</code>, но также убирает падающие объекты, которые достигли земли.</p>
<h3><a class="header" href="#Добавление-или-удаление-компонентов" id="Добавление-или-удаление-компонентов">Добавление или удаление компонентов</a></h3>
<p>Вы также можете вставить или удалить компоненты из определенной сущности. Для этого вам нужно получить изменяемое хранилище компонента, который вы хотите изменить, и просто выполните:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::{System, Entities, Entity, WriteStorage};
</span><span class="boring">struct MyComponent;
</span><span class="boring">impl amethyst::ecs::Component for MyComponent {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;MyComponent&gt;;
</span><span class="boring">}
</span><span class="boring">struct MySystem { entity: Entity }
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for MySystem {
</span><span class="boring">  type SystemData = WriteStorage&lt;'a, MyComponent&gt;;
</span><span class="boring">  fn run(&amp;mut self, mut write_storage: Self::SystemData) {
</span><span class="boring">      let entity = self.entity;
</span>// Add the component
write_storage.insert(entity, MyComponent);

// Remove the component
write_storage.remove(entity);
<span class="boring">  }
</span><span class="boring">}
</span></code></pre>
<p>Имейте в виду, что вставка компонента в сущность, которая уже имеет компонент того же типа, <em>перезапишет предыдущий</em>.</p>
<h2><a class="header" href="#Изменение-состояния-через-ресурсы" id="Изменение-состояния-через-ресурсы">Изменение состояния через ресурсы</a></h2>
<p>В одном из предыдущих разделов мы говорили о состояниях (<code>States</code>) и о том, как они используются для организации вашей игры в разные логические разделы. Иногда мы хотим инициировать переход состояния из системы. Например, если игрок умирает, мы можем захотеть удалить его сущность и дать сигнал конечному автомату выдвинуть состояние, которое показывает экран «Вы умерли».</p>
<p>Итак, как мы можем влиять на состояния из систем? Есть несколько способов, но в этом разделе мы рассмотрим самый простой: использование ресурса (<code>Resource</code>).</p>
<p>Перед этим давайте просто быстро напомним себе, что такое ресурс:</p>
<blockquote>
<p><code>Resource</code> - это любой тип, в котором хранятся данные, которые могут вам понадобиться для вашей игры, и которые не относятся к конкретной сущности.</p>
</blockquote>
<p>Данные в ресурсе доступны как для систем, так и для состояний. Мы можем использовать это в наших интересах!</p>
<p>Допустим, у вас есть два следующих состояния:</p>
<ul>
<li><code>GameplayState</code>: состояние, в котором запущена игра.</li>
<li><code>GameMenuState</code>: состояние, в котором игра приостановлена, и мы взаимодействуем с игровым меню.</li>
</ul>
<p>В следующем примере показано, как отслеживать в каком состоянии мы находимся в данный момент. Это позволяет нам сделать немного условной логики в наших системах, чтобы определить, что делать в зависимости от того, какое состояние в данный момент активно, и манипулировать состояниями, отслеживая действия пользователя.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::prelude::*;

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum CurrentState {
    MainMenu,
    Gameplay,
}

#[derive(Clone, Copy, Debug, PartialEq, Eq)]
enum UserAction {
    OpenMenu,
    ResumeGame,
    Quit,
}

impl Default for CurrentState {
    fn default() -&gt; Self {
        CurrentState::Gameplay
    }
}

struct Game {
    user_action: Option&lt;UserAction&gt;,
    current_state: CurrentState,
}

impl Default for Game {
    fn default() -&gt; Self {
        Game {
            user_action: None,
            current_state: CurrentState::default(),
        }
    }
}

struct GameplayState;

impl SimpleState for GameplayState {
    fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
        // Если ресурс `Game` был настроен для возврата в меню, нажмите
        // состояние меню, чтобы мы вернулись.

        let mut game = data.world.write_resource::&lt;Game&gt;();

        if let Some(UserAction::OpenMenu) = game.user_action.take() {
            return Trans::Push(Box::new(GameMenuState));
        }

        Trans::None
    }

    fn on_resume(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        // Отметьте, что текущее состояние является состоянием геймплея.
        data.world.write_resource::&lt;Game&gt;().current_state = CurrentState::Gameplay;
    }
}

struct GameMenuState;

impl SimpleState for GameMenuState {
    fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
        let mut game = data.world.write_resource::&lt;Game&gt;();

        match game.user_action.take() {
            Some(UserAction::ResumeGame) =&gt; Trans::Pop,
            Some(UserAction::Quit) =&gt; {
                // Примечание: убирать не нужно :)
                Trans::Quit
            },
            _ =&gt; Trans::None,
        }
    }

    fn on_resume(&amp;mut self, mut data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        // Отметьте, что текущее состояние является состоянием главного меню.
        data.world.write_resource::&lt;Game&gt;().current_state = CurrentState::MainMenu;
    }
}
</code></pre>
<p>Допустим, мы хотим, чтобы игрок мог нажать escape, чтобы войти в меню. Мы модифицируем наш обработчик ввода, чтобы отобразить действие <code>open_menu</code> на <code>Esc</code>, и мы пишем следующую систему:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">enum CurrentState {
</span><span class="boring">    MainMenu,
</span><span class="boring">    Gameplay,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for CurrentState { fn default() -&gt; Self { CurrentState::Gameplay } }
</span><span class="boring">
</span><span class="boring">#[derive(Clone, Copy, Debug, PartialEq, Eq)]
</span><span class="boring">enum UserAction {
</span><span class="boring">    OpenMenu,
</span><span class="boring">    ResumeGame,
</span><span class="boring">    Quit,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct Game {
</span><span class="boring">    user_action: Option&lt;UserAction&gt;,
</span><span class="boring">    current_state: CurrentState,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Default for Game {
</span><span class="boring">    fn default() -&gt; Self {
</span><span class="boring">        Game {
</span><span class="boring">            user_action: None,
</span><span class="boring">            current_state: CurrentState::default(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    prelude::*,
    ecs::{System, prelude::*},
    input::{InputHandler, StringBindings},
};

struct MyGameplaySystem;

impl&lt;'s&gt; System&lt;'s&gt; for MyGameplaySystem {
    type SystemData = (
        Read&lt;'s, InputHandler&lt;StringBindings&gt;&gt;,
        Write&lt;'s, Game&gt;,
    );

    fn run(&amp;mut self, (input, mut game): Self::SystemData) {
        match game.current_state {
            CurrentState::Gameplay =&gt; {
                let open_menu = input
                    .action_is_down(&quot;open_menu&quot;)
                    .unwrap_or(false);

                // Переключите переменную `open_menu`, чтобы указать состояние
                // перехода.
                if open_menu {
                    game.user_action = Some(UserAction::OpenMenu);
                }
            }
            // Ничего не делать для других состояний.
            _ =&gt; {}
        }
    }
}
</code></pre>
<p>Теперь, когда вы играете в игру и нажимаете кнопку, связанную с действием <code>open_menu</code>, <code>GameMenuState</code> возобновляется, а <code>GameplayState</code> приостанавливается.</p>
<h2><a class="header" href="#Типаж-systemdata" id="Типаж-systemdata">Типаж SystemData</a></h2>
<p>Хоть это и редко может быть полезно, но возможно создание пользовательских типов <code>SystemData</code>.</p>
<p><code>Dispatcher</code> заполняет <code>SystemData</code> при каждом вызове метода <code>run</code>. Чтобы сделать это, ваш тип <code>SystemData</code> должен реализовать типаж <code>amethyst::ecs::SystemData</code> для того, чтобы он был действительным.</p>
<p>Это довольно сложная черта для реализации, к счастью, Amethyst предоставляет для нее производный макрос, который может реализовать черту для любой структуры, если все ее поля - <code>SystemData</code>. Однако в большинстве случаев вам даже не нужно будет реализовывать это вообще, так как вы будете использовать структуры <code>SystemData</code>, предоставляемые движком.</p>
<p>Обратите внимание, что кортежи структур, реализующих <code>SystemData</code>, сами являются <code>SystemData</code>. Это очень полезно, когда вам нужно быстро запросить несколько <code>SystemData</code> одновременно.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">extern crate shred;
</span><span class="boring">#[macro_use] extern crate shred_derive;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::{Component, Join, ReadStorage, System, SystemData, VecStorage, World, WriteStorage},
</span><span class="boring">    shred::ResourceId,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">struct FooComponent {
</span><span class="boring">  stuff: f32,
</span><span class="boring">}
</span><span class="boring">impl Component for FooComponent {
</span><span class="boring">  type Storage = VecStorage&lt;FooComponent&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct BarComponent {
</span><span class="boring">  stuff: f32,
</span><span class="boring">}
</span><span class="boring">impl Component for BarComponent {
</span><span class="boring">  type Storage = VecStorage&lt;BarComponent&gt;;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(SystemData)]
</span><span class="boring">struct BazSystemData&lt;'a&gt; {
</span><span class="boring"> field: ReadStorage&lt;'a, FooComponent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; BazSystemData&lt;'a&gt; {
</span><span class="boring">  fn should_process(&amp;self) -&gt; bool {
</span><span class="boring">      true
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>#[derive(SystemData)]
struct MySystemData&lt;'a&gt; {
    foo: ReadStorage&lt;'a, FooComponent&gt;,
    bar: WriteStorage&lt;'a, BarComponent&gt;,
    baz: BazSystemData&lt;'a&gt;,
}

struct MyFirstSystem;

impl&lt;'a&gt; System&lt;'a&gt; for MyFirstSystem {
    type SystemData = MySystemData&lt;'a&gt;;

    fn run(&amp;mut self, mut data: Self::SystemData) {
        if data.baz.should_process() {
            for (foo, mut bar) in (&amp;data.foo, &amp;mut data.bar).join() {
                bar.stuff += foo.stuff;
            }
        }
    }
}
</code></pre>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Инициализация-системы" id="Инициализация-системы">Инициализация системы</a></h1>
<p>Системы могут нуждаться в доступе к ресурсам из <code>World</code>, чтобы быть реализованными. Например, получение <code>ReaderId</code> для <code>EventChannel</code>, который существует в <code>World</code>. Когда в <code>World</code> существует канал событий, <code>System</code> должна зарегистрироваться как читатель этого канала, а не заменить его, поскольку это делает недействительными всех других читателей.</p>
<p>В Amethyst <code>World</code>, с которого начинается приложение, заполняется несколькими ресурсами по умолчанию - каналами событий, пулом потоков, ограничителем кадров и так далее.</p>
<p>Поскольку ресурсы по умолчанию начинаются со специальных ограничений, нам нужен способ передать логику инициализации <code>System</code> в приложение, включая параметры в конструктор <code>System</code>. Это информация, которую захватывает типаж <code>SystemDesc</code>.</p>
<p>Для каждой <code>System</code> реализация признака <code>SystemDesc</code> определяет логику для создания экземпляра <code>System</code>. Для систем, которые не требуют специальной логики инициализации, <code>#[derive(SystemDesc)]</code> автоматически реализует типаж <code>SystemDesc</code> для типа системы:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span>use amethyst::{
    core::SystemDesc,
    derive::SystemDesc,
    ecs::{System, SystemData, World},
};

#[derive(SystemDesc)]
struct SystemName;

impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
    type SystemData = ();

    fn run(&amp;mut self, data: Self::SystemData) {
        println!(&quot;Hello!&quot;);
    }
}
</code></pre>
<p><a href="concepts/system/./chapter_3_part_5.2.html">Страница производная <code>SystemDesc</code></a> демонстрирует варианты использования, поддерживаемые производной <code>SystemDesc</code>. Для более сложных случаев страница <a href="concepts/system/./chapter_3_part_5.3.html">«Реализация типажа <code>SystemDesc</code>»</a> объясняет, как реализовать типаж <code>SystemDesc</code>.</p>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Производная-systemdesc" id="Производная-systemdesc">Производная SystemDesc</a></h1>
<p>Производная <code>SystemDesc</code> поддерживает следующие случаи при создании реализации типажа <code>SystemDesc</code>:</p>
<ul>
<li>Параметры для передачи в системный конструктор.</li>
<li>Поля для пропуска по умолчанию используемые системным конструктором.</li>
<li>Регистрация <code>ReaderId</code> для <code>EventChannel&lt;\_&gt;</code> в <code>World</code>.</li>
<li>Регистрация <code>ReaderId</code> в <code>FlaggedStorage</code> компонента.</li>
<li>Вставка ресурса в <code>World</code>.</li>
</ul>
<p>Если ваш сценарий использования для инициализации системы не описан, см. страницу <a href="concepts/system/./chapter_3_part_5.3.html">«Реализация типажа <code>SystemDesc</code>»</a>.</p>
<h2><a class="header" href="#Передача-параметров-в-системный-конструктор" id="Передача-параметров-в-системный-конструктор">Передача параметров в системный конструктор</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    field_0: u32,
    field_1: String,
}

impl SystemName {
    fn new(field_0: u32, field_1: String) -&gt; Self {
        SystemName { field_0, field_1 }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    field_0: u32,
</span><span class="boring">    field_1: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl SystemName {
</span><span class="boring">    fn new(field_0: u32, field_1: String) -&gt; Self {
</span><span class="boring">        SystemName { field_0, field_1 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Собирает `SystemName`.
#[derive(Default, Debug)]
pub struct SystemNameDesc {
    field_0: u32,
    field_1: String,
}

impl SystemNameDesc {
    fn new(field_0: u32, field_1: String) -&gt; Self {
        SystemNameDesc { field_0, field_1 }
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        SystemName::new(self.field_0, self.field_1)
    }
}
</code></pre>
</details>
<h2><a class="header" href="#Поля-для-пропуска-по-умолчанию--используемые-конструктором-системы" id="Поля-для-пропуска-по-умолчанию--используемые-конструктором-системы">Поля для пропуска по умолчанию  используемые конструктором системы</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    #[system_desc(skip)]
    field_0: u32,
    field_1: String,
}

impl SystemName {
    fn new(field_1: String) -&gt; Self {
        SystemName { field_0: 123, field_1 }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    field_0: u32,
</span><span class="boring">    field_1: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl SystemName {
</span><span class="boring">    fn new(field_1: String) -&gt; Self {
</span><span class="boring">        SystemName { field_0: 123, field_1 }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Собирает `SystemName`.
#[derive(Default, Debug)]
pub struct SystemNameDesc {
    field_1: String,
}

impl SystemNameDesc {
    fn new(field_1: String) -&gt; Self {
        SystemNameDesc { field_1 }
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        SystemName::new(self.field_1)
    }
}
</code></pre>
</details>
<p><strong>Примечание.</strong> Если параметры поля отсутствуют, реализация <code>SystemDesc</code> вызовет <code>SystemName::default()</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(Default, SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    #[system_desc(skip)]
    field_0: u32,
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    field_0: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Собирает `SystemName`.
#[derive(Debug)]
pub struct SystemNameDesc {}

impl Default for SystemNameDesc {
    fn default() -&gt; Self {
        SystemNameDesc {}
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        SystemName::default()
    }
}
</code></pre>
</details>
<h2><a class="header" href="#Регистрация-readerid-для-eventchannel_-в-world" id="Регистрация-readerid-для-eventchannel_-в-world">Регистрация <code>ReaderId</code> для <code>EventChannel&lt;\_&gt;</code> в <code>World</code>.</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">    shrev::{EventChannel, ReaderId},
</span><span class="boring">    ui::UiEvent,
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    #[system_desc(event_channel_reader)]
    reader_id: ReaderId&lt;UiEvent&gt;,
}

impl SystemName {
    fn new(reader_id: ReaderId&lt;UiEvent&gt;) -&gt; Self {
        SystemName { reader_id }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{System, SystemData},
</span><span class="boring">    shrev::{EventChannel, ReaderId},
</span><span class="boring">    ui::UiEvent,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    reader_id: ReaderId&lt;UiEvent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl SystemName {
</span><span class="boring">    fn new(reader_id: ReaderId&lt;UiEvent&gt;) -&gt; Self {
</span><span class="boring">        SystemName { reader_id }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Собирает `SystemName`.
#[derive(Debug)]
pub struct SystemNameDesc;

impl Default for SystemNameDesc {
    fn default() -&gt; Self {
        SystemNameDesc {}
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        let reader_id = world
            .fetch_mut::&lt;EventChannel&lt;UiEvent&gt;&gt;()
            .register_reader();

        SystemName::new(reader_id)
    }
}
</code></pre>
</details>
<h2><a class="header" href="#Регистрация-readerid-в-flaggedstorage-компонента" id="Регистрация-readerid-в-flaggedstorage-компонента">Регистрация <code>ReaderId</code> в <code>FlaggedStorage</code> компонента.</a></h2>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{storage::ComponentEvent, System, SystemData, WriteStorage},
</span><span class="boring">    shrev::{EventChannel, ReaderId},
</span><span class="boring">    ui::UiResize,
</span><span class="boring">};
</span><span class="boring">
</span>#[derive(SystemDesc)]
#[system_desc(name(SystemNameDesc))]
pub struct SystemName {
    #[system_desc(flagged_storage_reader(UiResize))]
    resize_events_id: ReaderId&lt;ComponentEvent&gt;,
}

impl SystemName {
    fn new(resize_events_id: ReaderId&lt;ComponentEvent&gt;) -&gt; Self {
        SystemName { resize_events_id }
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span></code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{storage::ComponentEvent, System, SystemData, WriteStorage},
</span><span class="boring">    shrev::{EventChannel, ReaderId},
</span><span class="boring">    ui::UiResize,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct SystemName {
</span><span class="boring">    resize_events_id: ReaderId&lt;ComponentEvent&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl SystemName {
</span><span class="boring">    fn new(resize_events_id: ReaderId&lt;ComponentEvent&gt;) -&gt; Self {
</span><span class="boring">        SystemName { resize_events_id }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Собирает `SystemName`.
#[derive(Debug)]
pub struct SystemNameDesc;

impl Default for SystemNameDesc {
    fn default() -&gt; Self {
        SystemNameDesc {}
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        let resize_events_id = WriteStorage::&lt;UiResize&gt;::fetch(&amp;world)
                            .register_reader();

        SystemName::new(resize_events_id)
    }
}
</code></pre>
</details>
<h2><a class="header" href="#Вставка-ресурса-в-world" id="Вставка-ресурса-в-world">Вставка ресурса в <code>World</code>.</a></h2>
<p><strong>Примечание.</strong> Если ресурс, который вы хотите вставить, является результатом выражения, такого как вызов функции, вы должны заключить это выражение в кавычки, например, <code>#[system_desc(insert(&quot;MyResource::default()&quot;))]</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{ReadExpect, System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span>pub struct NonDefault;

#[derive(Default, SystemDesc)]
#[system_desc(insert(NonDefault))]
pub struct SystemName;

impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
    type SystemData = ReadExpect&lt;'a, NonDefault&gt;;
    fn run(&amp;mut self, data: Self::SystemData) {}
}
</code></pre>
<details>
<summary>Generated code</summary>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span><span class="boring">use amethyst::{
</span><span class="boring">    derive::SystemDesc,
</span><span class="boring">    ecs::{ReadExpect, System, SystemData},
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">pub struct NonDefault;
</span><span class="boring">
</span><span class="boring">#[derive(Default)]
</span><span class="boring">pub struct SystemName;
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for SystemName {
</span><span class="boring">    type SystemData = ReadExpect&lt;'a, NonDefault&gt;;
</span><span class="boring">    fn run(&amp;mut self, data: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Собирает `SystemName`.
#[derive(Debug)]
pub struct SystemNameDesc;

impl Default for SystemNameDesc {
    fn default() -&gt; Self {
        SystemNameDesc {}
    }
}

impl&lt;'a, 'b&gt; ::amethyst::core::SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut ::amethyst::ecs::World) -&gt; SystemName {
        &lt;SystemName as ::amethyst::ecs::System&lt;'_&gt;&gt;::SystemData::setup(world);

        world.insert(NonDefault);

        SystemName::default()
    }
}
</code></pre>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>
<h1><a class="header" href="#Реализация-типажа-systemdesc" id="Реализация-типажа-systemdesc">Реализация типажа SystemDesc</a></h1>
<p>Если производная <code>SystemDesc</code> не может сгенерировать реализацию типажа <code>SystemDesc</code> для инициализации системы, типаж <code>SystemDesc</code> можно реализовать вручную:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">
</span>use amethyst::{
    audio::output::Output,
    core::SystemDesc,
    ecs::{System, SystemData, World},
};

<span class="boring">/// Syncs 3D transform data with the audio engine to provide 3D audio.
</span><span class="boring">#[derive(Debug, Default)]
</span><span class="boring">pub struct AudioSystem(Output);
</span><span class="boring">impl&lt;'a&gt; System&lt;'a&gt; for AudioSystem {
</span><span class="boring">    type SystemData = ();
</span><span class="boring">    fn run(&amp;mut self, _: Self::SystemData) {}
</span><span class="boring">}
</span><span class="boring">
</span>/// Собирает `AudioSystem`.
#[derive(Default, Debug)]
pub struct AudioSystemDesc {
    /// Аудио `Output`.
    pub output: Output,
}

impl&lt;'a, 'b&gt; SystemDesc&lt;'a, 'b, AudioSystem&gt; for AudioSystemDesc {
    fn build(self, world: &amp;mut World) -&gt; AudioSystem {
        &lt;AudioSystem as System&lt;'_&gt;&gt;::SystemData::setup(world);

        world.insert(self.output.clone());

        AudioSystem(self.output)
    }
}

// in `main.rs`:
// let game_data = GameDataBuilder::default()
//     .with_system_desc(AudioSystemDesc::default(), &quot;&quot;, &amp;[]);
</code></pre>
<h2><a class="header" href="#Шаблоны" id="Шаблоны">Шаблоны</a></h2>
<pre><code class="language-rust ignore">use amethyst_core::SystemDesc;

/// Собирает `SystemName`.
#[derive(Default, Debug)]
pub struct SystemNameDesc;

impl&lt;'a, 'b&gt; SystemDesc&lt;'a, 'b, SystemName&gt; for SystemNameDesc {
    fn build(self, world: &amp;mut World) -&gt; SystemName {
        &lt;SystemName as System&lt;'_&gt;&gt;::SystemData::setup(world);

        let arg = unimplemented!(&quot;Replace code here&quot;);

        SystemName::new(arg)
    }
}
</code></pre>
<p>С параметрами типа:</p>
<pre><code class="language-rust ignore">use std::marker::PhantomData;

use derivative::Derivative;

use amethyst_core::ecs::SystemData;
use amethyst_core::SystemDesc;

/// Собирает `SystemName`.
#[derive(Derivative, Debug)]
#[derivative(Default(bound = &quot;&quot;))]
pub struct SystemNameDesc&lt;T&gt; {
    marker: PhantomData&lt;T&gt;,
}

impl&lt;'a, 'b, T&gt; SystemDesc&lt;'a, 'b, SystemName&lt;T&gt;&gt;
    for SystemNameDesc&lt;T&gt;
where
    T: unimplemented!(&quot;Replace me.&quot;),
{
    fn build(self, world: &amp;mut World) -&gt; SystemName&lt;T&gt; {
        &lt;SystemName&lt;T&gt; as System&lt;'_&gt;&gt;::SystemData::setup(world);

        let arg = unimplemented!(&quot;Replace code here&quot;);

        SystemName::new(arg)
    }
}
</code></pre>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
