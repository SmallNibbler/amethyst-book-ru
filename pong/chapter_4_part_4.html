<!DOCTYPE HTML>
<html lang="ru" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Отрисовка и перемещение мяча - Amethyst Документация</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="../chapter_1.html"><strong aria-hidden="true">1.</strong> Введение</a></li><li class="expanded "><a href="../chapter_2.html"><strong aria-hidden="true">2.</strong> Начало работы</a></li><li class="expanded "><a href="../chapter_3.html"><strong aria-hidden="true">3.</strong> Концепции</a></li><li><ol class="section"><li class="expanded "><a href="../concepts/chapter_3_part_1.html"><strong aria-hidden="true">3.1.</strong> Состояния</a></li><li class="expanded "><a href="../concepts/chapter_3_part_2.html"><strong aria-hidden="true">3.2.</strong> Сущность и компонент</a></li><li class="expanded "><a href="../concepts/chapter_3_part_3.html"><strong aria-hidden="true">3.3.</strong> Ресурс</a></li><li class="expanded "><a href="../concepts/chapter_3_part_4.html"><strong aria-hidden="true">3.4.</strong> Мир</a></li><li class="expanded "><a href="../concepts/chapter_3_part_5.html"><strong aria-hidden="true">3.5.</strong> Система</a></li><li><ol class="section"><li class="expanded "><a href="../concepts/system/chapter_3_part_5.1.html"><strong aria-hidden="true">3.5.1.</strong> Инициализация системы</a></li><li class="expanded "><a href="../concepts/system/chapter_3_part_5.2.html"><strong aria-hidden="true">3.5.2.</strong> Производная SystemDesc</a></li><li class="expanded "><a href="../concepts/system/chapter_3_part_5.3.html"><strong aria-hidden="true">3.5.3.</strong> Реализация типажа SystemDesc</a></li></ol></li><li class="expanded "><a href="../concepts/chapter_3_part_6.html"><strong aria-hidden="true">3.6.</strong> Диспетчер</a></li><li class="expanded "><a href="../concepts/chapter_3_part_7.html"><strong aria-hidden="true">3.7.</strong> Канал событий</a></li></ol></li><li class="expanded "><a href="../chapter_4.html"><strong aria-hidden="true">4.</strong> Игра Понг</a></li><li><ol class="section"><li class="expanded "><a href="../pong/chapter_4_part_1.html"><strong aria-hidden="true">4.1.</strong> Настройка проекта</a></li><li class="expanded "><a href="../pong/chapter_4_part_2.html"><strong aria-hidden="true">4.2.</strong> Отрисовка ракеток</a></li><li class="expanded "><a href="../pong/chapter_4_part_3.html"><strong aria-hidden="true">4.3.</strong> Перемещение ракеток</a></li><li class="expanded "><a href="../pong/chapter_4_part_4.html" class="active"><strong aria-hidden="true">4.4.</strong> Отрисовка и перемещение мяча</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Amethyst Документация</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#Отрисовка-и-перемещение-мяча" id="Отрисовка-и-перемещение-мяча">Отрисовка и перемещение мяча</a></h1>
<p>В предыдущей главе мы узнали, как захватывать пользовательский ввод, чтобы заставить вещи двигаться на экране, при помощи систем. В этой главе будут использованы все знания, полученные нами в предыдущих главах, чтобы добавить в нашу игру новый объект: шар, который движется и подпрыгивает!</p>
<p>Во-первых, давайте определим некоторые другие полезные константы для этой главы в pong.rs:</p>
<pre><code class="language-rust edition2018 no_run noplaypen">pub const BALL_VELOCITY_X: f32 = 75.0;
pub const BALL_VELOCITY_Y: f32 = 50.0;
pub const BALL_RADIUS: f32 = 2.0;
</code></pre>
<p>Это также можно сделать с помощью внешнего файла конфигурации. Это особенно полезно, когда вы хотите много редактировать значения. Здесь мы делаем это просто.</p>
<h2><a class="header" href="#Компонент-ball" id="Компонент-ball">Компонент Ball</a></h2>
<p>В <code>pong.rs</code> давайте создадим компонент <code>Ball</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::prelude::{Component, DenseVecStorage};
</span>pub struct Ball {
    pub velocity: [f32; 2],
    pub radius: f32,
}

impl Component for Ball {
    type Storage = DenseVecStorage&lt;Self&gt;;
}
</code></pre>
<p>Мяч имеет скорость и радиус, поэтому мы храним эту информацию в компоненте.</p>
<p>Затем давайте добавим функцию <code>initialise_ball</code> так же, как мы написали функцию <code>initialise_paddles</code>.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::assets::{Loader, AssetStorage, Handle};
</span><span class="boring">use amethyst::renderer::{Texture, SpriteRender, Sprite, SpriteSheet};
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">use amethyst::core::transform::Transform;
</span><span class="boring">use amethyst::ecs::prelude::{Component, DenseVecStorage};
</span><span class="boring">pub struct Ball {
</span><span class="boring">   pub velocity: [f32; 2],
</span><span class="boring">   pub radius: f32,
</span><span class="boring">}
</span><span class="boring">impl Component for Ball {
</span><span class="boring">   type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">const PADDLE_HEIGHT: f32 = 16.0;
</span><span class="boring">const PADDLE_WIDTH: f32 = 4.0;
</span><span class="boring">const SPRITESHEET_SIZE: (f32, f32) = (8.0, 16.0);
</span><span class="boring">const BALL_RADIUS: f32 = 2.0;
</span><span class="boring">const BALL_VELOCITY_X: f32 = 75.0;
</span><span class="boring">const BALL_VELOCITY_Y: f32 = 50.0;
</span><span class="boring">const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">const ARENA_WIDTH: f32 = 100.0;
</span>/// Инициализируем один мяч в середине арены
fn initialise_ball(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) {
    // Перемещаем.
    let mut local_transform = Transform::default();
    local_transform.set_translation_xyz(ARENA_WIDTH / 2.0, ARENA_HEIGHT / 2.0, 0.0);

    // Назначаем спрайт для мяча
    let sprite_render = SpriteRender {
        sprite_sheet: sprite_sheet_handle,
        sprite_number: 1, // Мяч идёт вторым спрайтом на спрайт-листе
    };

    world
        .create_entity()
        .with(sprite_render)
        .with(Ball {
            radius: BALL_RADIUS,
            velocity: [BALL_VELOCITY_X, BALL_VELOCITY_Y],
        })
        .with(local_transform)
        .build();
}
</code></pre>
<p>В <a href="chapter_4_part_2.html#%D0%9E%D1%82%D1%80%D0%B8%D1%81%D0%BE%D0%B2%D0%BA%D0%B0">предыдущей главе</a> мы видели, как загрузить спрайт-лист и получить их отображение на экране. Запомните информация спрайт-листа хранится в <code>pong_spritesheet.ron</code>, а спрайт шара был второй, с индексом <code>1</code>.</p>
<p>Наконец, давайте удостоверимся, что код работает так, как задумано, обновив метод <code>on_start</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::assets::Handle;
</span><span class="boring">use amethyst::renderer::{Texture, SpriteSheet};
</span><span class="boring">use amethyst::ecs::World;
</span><span class="boring">struct Paddle;
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">struct Ball;
</span><span class="boring">impl amethyst::ecs::Component for Ball {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">fn initialise_ball(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, spritesheet: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; { unimplemented!() }
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
    let world = data.world;

    // Загрузка спрайт-листа необходима для отображения графики
    let sprite_sheet_handle = load_sprite_sheet(world);

    world.register::&lt;Ball&gt;(); // &lt;- Временно добавим эту строку

    initialise_ball(world, sprite_sheet_handle.clone()); // &lt;- Добавим эту строку
    initialise_paddles(world, sprite_sheet_handle);
    initialise_camera(world);
}
<span class="boring">}
</span></code></pre>
<p>Не забудьте вызвать <code>clone</code> для<code> sprite_sheet_handle</code>, потому что <code>initialise_paddles</code> и <code>initialise_ball</code> <em>потребляет</em> дескриптор.</p>
<p>Запустив игру сейчас, вы сможете увидеть два весла и мяч в центре. В следующем разделе мы собираемся заставить этот шар двигаться!</p>
<h2><a class="header" href="#Перемещение-мяча" id="Перемещение-мяча">Перемещение мяча</a></h2>
<p>Теперь мы готовы реализовать <code>MoveBallsSystem</code> в<code> systems/move_balls.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::prelude::{Component, DenseVecStorage};
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">       pub velocity: [f32; 2],
</span><span class="boring">       pub radius: f32,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">       type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    core::timing::Time,
    core::transform::Transform,
    core::SystemDesc,
    derive::SystemDesc,
    ecs::prelude::{Join, Read, ReadStorage, System, SystemData, World, WriteStorage},
};

use crate::pong::Ball;

#[derive(SystemDesc)]
pub struct MoveBallsSystem;

impl&lt;'s&gt; System&lt;'s&gt; for MoveBallsSystem {
    type SystemData = (
        ReadStorage&lt;'s, Ball&gt;,
        WriteStorage&lt;'s, Transform&gt;,
        Read&lt;'s, Time&gt;,
    );

    fn run(&amp;mut self, (balls, mut locals, time): Self::SystemData) {
        // Перемещаем каждый шар в соответствии с его скоростью и прошедшим временем
        for (ball, local) in (&amp;balls, &amp;mut locals).join() {
            local.prepend_translation_x(ball.velocity[0] * time.delta_seconds());
            local.prepend_translation_y(ball.velocity[1] * time.delta_seconds());
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>Эта система отвечает за перемещение всех мячей в соответствии с их скоростью и прошедшим временем. Обратите внимание, как метод <code>join()</code> используется для итерации по всем сущностям мячей. Здесь у нас есть только один мяч, но если нам когда-либо понадобится несколько, система будет обрабатывать и другие. В этой системе мы также хотим <em>независимость от частоты кадров</em>. То есть, независимо от частоты кадров, все объекты движутся с одинаковой скоростью. Для этого используется <strong>дельта времени</strong>, которое является продолжительностью с момента последнего кадра. Это обычно известно как [&quot;delta timing&quot;] <a href="https://en.wikipedia.org/wiki/Delta_timing">delta-timing</a>. Как видно из фрагмента, чтобы получить доступ к времени, прошедшему с момента последнего кадра, вам нужно использовать ресурс <a href="https://docs.amethyst.rs/stable/amethyst_core/timing/struct.Time.html"><code>amethyst::core::timing::Time</code></a>. У него есть метод, называемый <code>delta_seconds</code>, который делает именно то, что нам нужно.</p>
<p>Теперь, когда наш мяч может двигаться, давайте внедрим новую систему: <code>BounceSystem</code> в <code>systems/bounce.rs</code>. Он будет отвечать за обнаружение столкновений между шарами и ракетками, а также шарами и верхним и нижним краем арены. При обнаружении столкновения мяч отскакивает. Это делается с помощью изменения скорости компонента <code>Ball</code> оси <code>x</code> или <code>y</code> на отрицательную.</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::ecs::prelude::{Component, DenseVecStorage};
</span><span class="boring">
</span><span class="boring">mod pong {
</span><span class="boring">    use amethyst::ecs::prelude::*;
</span><span class="boring">
</span><span class="boring">    pub struct Ball {
</span><span class="boring">       pub velocity: [f32; 2],
</span><span class="boring">       pub radius: f32,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Ball {
</span><span class="boring">       type Storage = DenseVecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[derive(PartialEq, Eq)]
</span><span class="boring">    pub enum Side {
</span><span class="boring">      Left,
</span><span class="boring">      Right,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub struct Paddle {
</span><span class="boring">      pub side: Side,
</span><span class="boring">      pub width: f32,
</span><span class="boring">      pub height: f32,
</span><span class="boring">    }
</span><span class="boring">    impl Component for Paddle {
</span><span class="boring">      type Storage = VecStorage&lt;Self&gt;;
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub const ARENA_HEIGHT: f32 = 100.0;
</span><span class="boring">}
</span><span class="boring">
</span>use amethyst::{
    core::{Transform, SystemDesc},
    derive::SystemDesc,
    ecs::prelude::{Join, ReadStorage, System, SystemData, World, WriteStorage},
};

use crate::pong::{Ball, Side, Paddle, ARENA_HEIGHT};

<span class="boring">#[derive(SystemDesc)]
</span>pub struct BounceSystem;

impl&lt;'s&gt; System&lt;'s&gt; for BounceSystem {
    type SystemData = (
        WriteStorage&lt;'s, Ball&gt;,
        ReadStorage&lt;'s, Paddle&gt;,
        ReadStorage&lt;'s, Transform&gt;,
    );

    fn run(&amp;mut self, (mut balls, paddles, transforms): Self::SystemData) {
        // Проверяем, не столкнулся ли мяч, и отскакиваем соответственно.
        //
        // Мы также проверяем скорость мяча каждый раз, чтобы предотвратить множественные столкновения
        for (ball, transform) in (&amp;mut balls, &amp;transforms).join() {
            let ball_x = transform.translation().x;
            let ball_y = transform.translation().y;

            // Отскакивание от вершины или нижней части арены.
            if (ball_y &lt;= ball.radius &amp;&amp; ball.velocity[1] &lt; 0.0)
                || (ball_y &gt;= ARENA_HEIGHT - ball.radius &amp;&amp; ball.velocity[1] &gt; 0.0)
            {
                ball.velocity[1] = -ball.velocity[1];
            }

            // Отскакивание от ракетки
            for (paddle, paddle_transform) in (&amp;paddles, &amp;transforms).join() {
                let paddle_x = paddle_transform.translation().x - (paddle.width * 0.5);
                let paddle_y = paddle_transform.translation().y - (paddle.height * 0.5);

                // Чтобы определить столкнулся ли мяч с ракеткой, мы создаём больший
                // прямоугольник вокруг текущего, вычитая радиус мяча из
                // нижних координат, и добавляя радиус мяча к верхним.
                // Мяч находиться внутри ракетки, когда его центр находится внутри большего
                // прямоугольника-обёртки.
                if point_in_rect(
                    ball_x,
                    ball_y,
                    paddle_x - ball.radius,
                    paddle_y - ball.radius,
                    paddle_x + paddle.width + ball.radius,
                    paddle_y + paddle.height + ball.radius,
                ) {
                    if (paddle.side == Side::Left &amp;&amp; ball.velocity[0] &lt; 0.0)
                        || (paddle.side == Side::Right &amp;&amp; ball.velocity[0] &gt; 0.0)
                    {
                        ball.velocity[0] = -ball.velocity[0];
                    }
                }
            }
        }
    }
}

// Точка находится в прямоугольнике когда её координаты
// меньше или равны правому верхнему углу и больше или равны левому нижнему углу.
fn point_in_rect(x: f32, y: f32, left: f32, bottom: f32, right: f32, top: f32) -&gt; bool {
    x &gt;= left &amp;&amp; x &lt;= right &amp;&amp; y &gt;= bottom &amp;&amp; y &lt;= top
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre>
<p>На следующем рисунке показано, как проверяются столкновения с ракетками.</p>
<p><img src="../images/pong_paddle_collision.png" alt="Объяснение столкновений" /></p>
<p>Также не забудьте добавить <code>mod move_balls</code> и <code>mod bounce</code> в <code>systems/mod.rs</code> а также добавление наших новых систем к игровым данным:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">use amethyst::core::transform::TransformBundle;
</span><span class="boring">use amethyst::window::DisplayConfig;
</span><span class="boring">use amethyst::input::StringBindings;
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">let path = &quot;./config/display.ron&quot;;
</span><span class="boring">let config = DisplayConfig::load(&amp;path)?;
</span><span class="boring">mod systems {
</span><span class="boring">use amethyst;
</span><span class="boring">use amethyst::core::ecs::{System, SystemData, World};
</span><span class="boring">use amethyst::core::SystemDesc;
</span><span class="boring">use amethyst::derive::SystemDesc;
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct PaddleSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for PaddleSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct MoveBallsSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for MoveBallsSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">#[derive(SystemDesc)]
</span><span class="boring">pub struct BounceSystem;
</span><span class="boring">impl&lt;'a&gt; amethyst::ecs::System&lt;'a&gt; for BounceSystem {
</span><span class="boring">type SystemData = ();
</span><span class="boring">fn run(&amp;mut self, _: Self::SystemData) { }
</span><span class="boring">}
</span><span class="boring">}
</span><span class="boring">let input_bundle = amethyst::input::InputBundle::&lt;StringBindings&gt;::new();
</span>let game_data = GameDataBuilder::default()
<span class="boring">   .with_bundle(TransformBundle::new())?
</span><span class="boring">   .with_bundle(input_bundle)?
</span><span class="boring">   .with(systems::PaddleSystem, &quot;paddle_system&quot;, &amp;[&quot;input_system&quot;])
</span>    // ...другие системы...
    .with(systems::MoveBallsSystem, &quot;ball_system&quot;, &amp;[])
    .with(
        systems::BounceSystem,
        &quot;collision_system&quot;,
        &amp;[&quot;paddle_system&quot;, &quot;ball_system&quot;],
    );
<span class="boring">let assets_dir = &quot;/&quot;;
</span><span class="boring">struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">let mut game = Application::new(assets_dir, Pong, game_data)?;
</span><span class="boring">Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Теперь у вас должен быть мяч, движущийся и отскакивающий от ракетки и от верхней и нижней части экрана. Тем не менее, вы быстро заметите, что если мяч выходит за пределы экрана справа или слева, он никогда не возвращается и игра окончена. Вы можете даже не увидеть этого, так как мяч может быть уже за пределами экрана, когда появляется окно. Возможно, вам придется резко сократить <code>BALL_VELOCITY_X</code>, чтобы увидеть это в действии. Это, очевидно, не очень хорошее решение для реальной игры. Чтобы решить эту проблему и лучше увидеть, что происходит, мы должны порождать мяч с небольшой задержкой.</p>
<h2><a class="header" href="#Создаём-мяч-с-задержкой" id="Создаём-мяч-с-задержкой">Создаём мяч с задержкой</a></h2>
<p>Мяч теперь появляется и исчезает с экрана сразу после начала игры. Это может дезориентировать, так как вас бросают в игру и вы сразу теряете свое первое очко, прежде чем у вас было время, чтобы что то заметить. Нам также нужно дать время для операционной системы и средства визуализации для инициализации окна до начала игры. Обычно у вас есть отдельное состояние с игровым меню, так что это не проблема. Но наша игра бросает вас прямо в действие, поэтому мы должны решить эту проблему.</p>
<p>Давайте сделаем задержку до первого появления мяча. Это также хорошая возможность использовать структуру нашего игрового состояния для содержания некоторых данных.</p>
<p>Во-первых, давайте добавим новый метод в наше состояние: <code>update</code>. Давайте добавим метод <code>update</code> чуть ниже метода <code>on_start</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::prelude::*;
</span><span class="boring">struct MyState;
</span><span class="boring">impl SimpleState for MyState {
</span>fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
    Trans::None
}
<span class="boring">}
</span></code></pre>
<p>Этот метод позволяет вам переходить из состояния, используя его возвращаемое значение. Здесь мы не хотим изменять никакое состояние, поэтому мы возвращаем <code>Trans::None</code>.</p>
<p>Теперь нам нужно перенести создание ракетки в этот метод и добавить к нему некоторую задержку. Наш <code>update</code> запускает каждый кадр, таким образом, чтобы сделать что-то только один раз после определенного времени, мы должны использовать наше локальное состояние. Кроме того, обратите внимание, что для «initialise_paddles» требуется, чтобы мы предоставили «sprite_sheet_handle», но он был создан как локальная переменная внутри <code>on_start</code>. По этой причине мы должны сделать его частью состояния.</p>
<p>Давайте добавим несколько полей в нашу структуру <code>Pong</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst; use amethyst::renderer::SpriteSheet;
</span><span class="boring">use amethyst::assets::Handle;
</span>#[derive(Default)]
pub struct Pong {
    ball_spawn_timer: Option&lt;f32&gt;,
    sprite_sheet_handle: Option&lt;Handle&lt;SpriteSheet&gt;&gt;,
}
</code></pre>
<p>Наш таймер представлен параметром <code>Option &lt;f32&gt;</code>, который будет отсчитываться до нуля, когда доступен, и будет заменен на <code>None</code> после того как пройдёт время. Наш дескриптор спрайт-листа также находится внутри <code>Option</code>, потому что мы не можем создать его внутри конструктора <code>Pong</code>. Вместо этого он будет создан внутри метода <code>on_start</code>.</p>
<p>Мы также добавили <code>#[derive(Default)]</code>, который автоматически реализует для нас черту <code>Default</code>, которая позволяет создавать пустое состояние по умолчанию. Теперь давайте используем это в нашем коде создания <code>Application</code> в<code> main.rs</code>:</p>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{
</span><span class="boring">    ecs::{World, WorldExt},
</span><span class="boring">    prelude::*,
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">#[derive(Default)] struct Pong;
</span><span class="boring">impl SimpleState for Pong { }
</span><span class="boring">fn main() -&gt; amethyst::Result&lt;()&gt; {
</span><span class="boring">  let game_data = GameDataBuilder::default();
</span><span class="boring">  let assets_dir = &quot;/&quot;;
</span><span class="boring">  let world = World::new();
</span>let mut game = Application::new(assets_dir, Pong::default(), game_data)?;
<span class="boring">  Ok(())
</span><span class="boring">}
</span></code></pre>
<p>Теперь давайте закончим наш код созданием таймера и мяча. Мы должны сделать две вещи:</p>
<ul>
<li>Сначала мы должны инициализировать наше состояние и удалить <code>initialise_ball</code> из<code> on_start</code>;</li>
<li>После мы должны инициализировать мяч функцией <code>initialise_ball</code> один раз по истечении времени внутри<code> update</code>.</li>
</ul>
<pre><code class="language-rust edition2018 no_run noplaypen"><span class="boring">extern crate amethyst;
</span><span class="boring">use amethyst::{assets::Handle, renderer::SpriteSheet};
</span><span class="boring">use amethyst::prelude::*;
</span>use amethyst::core::timing::Time;

<span class="boring">struct Paddle;
</span><span class="boring">impl amethyst::ecs::Component for Paddle {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">struct Ball;
</span><span class="boring">impl amethyst::ecs::Component for Ball {
</span><span class="boring">  type Storage = amethyst::ecs::VecStorage&lt;Self&gt;;
</span><span class="boring">}
</span><span class="boring">fn initialise_ball(world: &amp;mut World, sprite_sheet_handle: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_paddles(world: &amp;mut World, spritesheet: Handle&lt;SpriteSheet&gt;) { }
</span><span class="boring">fn initialise_camera(world: &amp;mut World) { }
</span><span class="boring">fn load_sprite_sheet(world: &amp;mut World) -&gt; Handle&lt;SpriteSheet&gt; { unimplemented!() }
</span><span class="boring">#[derive(Default)] pub struct Pong {
</span><span class="boring">    ball_spawn_timer: Option&lt;f32&gt;,
</span><span class="boring">    sprite_sheet_handle: Option&lt;Handle&lt;SpriteSheet&gt;&gt;,
</span><span class="boring">}
</span><span class="boring">
</span>impl SimpleState for Pong {
    fn on_start(&amp;mut self, data: StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) {
        let world = data.world;

        // Ждём одну секунду, прежде чем создать мяч.
        self.ball_spawn_timer.replace(1.0);

        // Загрузка спрайт-листа, необходимого для визуализации графики.
        // `spritesheet` это расположение спрайтов на изображении;
        // `texture` это данные пикселей.
        self.sprite_sheet_handle.replace(load_sprite_sheet(world));
        initialise_paddles(world, self.sprite_sheet_handle.clone().unwrap());
        initialise_camera(world);
    }

    fn update(&amp;mut self, data: &amp;mut StateData&lt;'_, GameData&lt;'_, '_&gt;&gt;) -&gt; SimpleTrans {
        if let Some(mut timer) = self.ball_spawn_timer.take() {
            // Если время таймера еще не истекло, вычтите время, прошедшее с момента последнего обновления.
            {
                let time = data.world.fetch::&lt;Time&gt;();
                timer -= time.delta_seconds();
            }
            if timer &lt;= 0.0 {
                // Когда таймер истекает, появляется мяч
                initialise_ball(data.world, self.sprite_sheet_handle.clone().unwrap());
            } else {
                // Если время таймера еще не истекло, возвращаем его в состояние.
                self.ball_spawn_timer.replace(timer);
            }
        }
        Trans::None
    }
}
</code></pre>
<p>Теперь наш мяч появится только после заданной задержки, что даст нам немного времени перед запуском. Это позволит нам увидеть, что происходит с мячом сразу после его появления.</p>
<h2><a class="header" href="#Подведём-итог" id="Подведём-итог">Подведём итог</a></h2>
<p>В этой главе мы наконец добавили мяч в нашу игру. Как всегда, полный код доступен в репозитории Amethyst. В следующей главе мы добавим проверку системой, когда игрок проигрывает игру, и добавим систему начисления очков!</p>
<hr />
<p>Документация была переведена специально для сообщества &quot;<strong>rust_lang_ru</strong>&quot;.</p>
<p>Подпишись на нас в <strong><a href="http://tlinks.run/rust_lang_ru">Telegram</a></strong> и <strong><a href="https://www.youtube.com/channel/UCu413rnSfuSSOR3OsIThlZA">YouTube</a></strong>!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../pong/chapter_4_part_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../pong/chapter_4_part_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
